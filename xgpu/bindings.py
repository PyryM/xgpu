# AUTOGENERATED
from abc import ABC, abstractmethod
from enum import IntEnum
from typing import Any, Callable, Iterator, List, Optional, Union

from ._wgpu_native_cffi import ffi, lib


def getFunnyVersionName() -> str:
    return "bronzed-bunting"


# make typing temporarily happy until I can figure out if there's
# a better way to have type information about CData fields
CData = Any


def _ffi_new(typespec: str, count: Optional[int] = None) -> CData:
    return ffi.new(typespec, count)


def _ffi_init(typespec: str, initializer: Optional[Any]) -> CData:
    if initializer is None:
        return ffi.new(typespec)
    else:
        return initializer


def _ffi_deref(cdata: CData) -> None:
    if ffi.typeof(cdata).kind == "pointer":
        return cdata[0]
    else:
        return cdata


def _ffi_unwrap_optional(val: Optional[Any]) -> CData:
    if val is None:
        return ffi.NULL
    else:
        return val._cdata


def _ffi_unwrap_str(val: Optional[str]) -> CData:
    if val is None:
        val = ""
    return ffi.new("char[]", val.encode("utf8"))


def _ffi_string(val: CData) -> str:
    if val == ffi.NULL:
        return ""
    ret = ffi.string(val)
    if isinstance(ret, bytes):
        return ret.decode("utf8")
    elif isinstance(ret, str):
        return ret
    else:
        raise RuntimeError("IMPOSSIBLE")


def _cast_userdata(ud: CData) -> int:
    return ffi.cast("int", ud)


class Chainable(ABC):
    @property
    @abstractmethod
    def _chain(self) -> Any: ...


class ChainedStruct:
    def __init__(self, chain: List["Chainable"]):
        self.chain = chain
        if len(chain) == 0:
            self._cdata = ffi.NULL
            return
        self._cdata = ffi.addressof(chain[0]._chain)
        next_ptrs = [ffi.addressof(link._chain) for link in chain[1:]] + [ffi.NULL]
        for idx, ptr in enumerate(next_ptrs):
            chain[idx]._chain.next = ptr


# TODO: figure out a nicer way to generically handle this
# (because despite being layout-identical these two types
#  are actually different!)
ChainedStructOut = ChainedStruct


class CBMap:
    def __init__(self):
        self.callbacks = {}
        self.index = 0

    def add(self, cb: Any) -> int:
        retidx = self.index
        self.index += 1
        self.callbacks[retidx] = cb
        return retidx

    def get(self, idx: int) -> Any:
        return self.callbacks.get(idx)

    def remove(self, idx: int) -> None:
        if idx in self.callbacks:
            del self.callbacks[idx]


def _ffi_void_cast(thing: Any) -> CData:
    return ffi.cast("void *", thing)


class VoidPtr:
    NULL: "VoidPtr"

    @classmethod
    def raw_cast(cls, ptr: Any) -> "VoidPtr":
        return VoidPtr(_ffi_void_cast(ptr))

    def __init__(self, ptr: CData):
        self._ptr = ptr


VoidPtr.NULL = VoidPtr(ffi.NULL)


class DataPtr:
    NULL: "DataPtr"

    @classmethod
    def allocate(cls, size: int) -> "DataPtr":
        return DataPtr(ffi.new("char[]", size), size)

    @classmethod
    def wrap(cls, buffer: Any) -> "DataPtr":
        cdata = ffi.from_buffer(buffer)
        return DataPtr(cdata, len(cdata))

    def __init__(self, data: CData, size: int):
        self._ptr = data
        self._size = size

    def buffer_view(self) -> Any:
        return ffi.buffer(self._ptr, self._size)

    def copy_bytes(self, src: bytes, count: Optional[int] = None) -> None:
        if count is None:
            count = len(src)
        ffi.memmove(self._ptr, src, count)

    def to_bytes(self) -> bytes:
        return bytes(self.buffer_view())


DataPtr.NULL = DataPtr(data=ffi.NULL, size=0)


def getVersionStr() -> str:
    version_int = getVersion()
    a = (version_int >> 24) & 0xFF
    b = (version_int >> 16) & 0xFF
    c = (version_int >> 8) & 0xFF
    d = (version_int >> 0) & 0xFF
    return f"{a}.{b}.{c}.{d}"


# Basic types
class AdapterType(IntEnum):
    DiscreteGPU = 0x00000000
    IntegratedGPU = 0x00000001
    CPU = 0x00000002
    Unknown = 0x00000003


class AddressMode(IntEnum):
    Repeat = 0x00000000
    MirrorRepeat = 0x00000001
    ClampToEdge = 0x00000002


class BackendType(IntEnum):
    Undefined = 0x00000000
    Null = 0x00000001
    WebGPU = 0x00000002
    D3D11 = 0x00000003
    D3D12 = 0x00000004
    Metal = 0x00000005
    Vulkan = 0x00000006
    OpenGL = 0x00000007
    OpenGLES = 0x00000008


class BlendFactor(IntEnum):
    Zero = 0x00000000
    One = 0x00000001
    Src = 0x00000002
    OneMinusSrc = 0x00000003
    SrcAlpha = 0x00000004
    OneMinusSrcAlpha = 0x00000005
    Dst = 0x00000006
    OneMinusDst = 0x00000007
    DstAlpha = 0x00000008
    OneMinusDstAlpha = 0x00000009
    SrcAlphaSaturated = 0x0000000A
    Constant = 0x0000000B
    OneMinusConstant = 0x0000000C


class BlendOperation(IntEnum):
    Add = 0x00000000
    Subtract = 0x00000001
    ReverseSubtract = 0x00000002
    Min = 0x00000003
    Max = 0x00000004


class BufferBindingType(IntEnum):
    Undefined = 0x00000000
    Uniform = 0x00000001
    Storage = 0x00000002
    ReadOnlyStorage = 0x00000003


class BufferMapAsyncStatus(IntEnum):
    Success = 0x00000000
    ValidationError = 0x00000001
    Unknown = 0x00000002
    DeviceLost = 0x00000003
    DestroyedBeforeCallback = 0x00000004
    UnmappedBeforeCallback = 0x00000005
    MappingAlreadyPending = 0x00000006
    OffsetOutOfRange = 0x00000007
    SizeOutOfRange = 0x00000008


class BufferMapState(IntEnum):
    Unmapped = 0x00000000
    Pending = 0x00000001
    Mapped = 0x00000002


class CompareFunction(IntEnum):
    Undefined = 0x00000000
    Never = 0x00000001
    Less = 0x00000002
    LessEqual = 0x00000003
    Greater = 0x00000004
    GreaterEqual = 0x00000005
    Equal = 0x00000006
    NotEqual = 0x00000007
    Always = 0x00000008


class CompilationInfoRequestStatus(IntEnum):
    Success = 0x00000000
    Error = 0x00000001
    DeviceLost = 0x00000002
    Unknown = 0x00000003


class CompilationMessageType(IntEnum):
    Error = 0x00000000
    Warning = 0x00000001
    Info = 0x00000002


class CompositeAlphaMode(IntEnum):
    Auto = 0x00000000
    Opaque = 0x00000001
    Premultiplied = 0x00000002
    Unpremultiplied = 0x00000003
    Inherit = 0x00000004


class CreatePipelineAsyncStatus(IntEnum):
    Success = 0x00000000
    ValidationError = 0x00000001
    InternalError = 0x00000002
    DeviceLost = 0x00000003
    DeviceDestroyed = 0x00000004
    Unknown = 0x00000005


class CullMode(IntEnum):
    _None = 0x00000000
    Front = 0x00000001
    Back = 0x00000002


class DeviceLostReason(IntEnum):
    Unknown = 0x00000001
    Destroyed = 0x00000002


class ErrorFilter(IntEnum):
    Validation = 0x00000000
    OutOfMemory = 0x00000001
    Internal = 0x00000002


class ErrorType(IntEnum):
    NoError = 0x00000000
    Validation = 0x00000001
    OutOfMemory = 0x00000002
    Internal = 0x00000003
    Unknown = 0x00000004
    DeviceLost = 0x00000005


class FeatureName(IntEnum):
    Undefined = 0x00000000
    DepthClipControl = 0x00000001
    Depth32FloatStencil8 = 0x00000002
    TimestampQuery = 0x00000003
    TextureCompressionBC = 0x00000004
    TextureCompressionETC2 = 0x00000005
    TextureCompressionASTC = 0x00000006
    IndirectFirstInstance = 0x00000007
    ShaderF16 = 0x00000008
    RG11B10UfloatRenderable = 0x00000009
    BGRA8UnormStorage = 0x0000000A
    Float32Filterable = 0x0000000B
    PushConstants = 0x00030001
    TextureAdapterSpecificFormatFeatures = 0x00030002
    MultiDrawIndirect = 0x00030003
    MultiDrawIndirectCount = 0x00030004
    VertexWritableStorage = 0x00030005
    TextureBindingArray = 0x00030006
    SampledTextureAndStorageBufferArrayNonUniformIndexing = 0x00030007
    PipelineStatisticsQuery = 0x00030008
    StorageResourceBindingArray = 0x00030009
    PartiallyBoundBindingArray = 0x0003000A
    TextureFormat16bitNorm = 0x0003000B
    TextureCompressionAstcHdr = 0x0003000C
    MappablePrimaryBuffers = 0x0003000E
    BufferBindingArray = 0x0003000F
    UniformBufferAndStorageTextureArrayNonUniformIndexing = 0x00030010
    VertexAttribute64bit = 0x00030019
    TextureFormatNv12 = 0x0003001A
    RayTracingAccelerationStructure = 0x0003001B
    RayQuery = 0x0003001C
    ShaderF64 = 0x0003001D
    ShaderI16 = 0x0003001E
    ShaderPrimitiveIndex = 0x0003001F
    ShaderEarlyDepthTest = 0x00030020


class FilterMode(IntEnum):
    Nearest = 0x00000000
    Linear = 0x00000001


class FrontFace(IntEnum):
    CCW = 0x00000000
    CW = 0x00000001


class IndexFormat(IntEnum):
    Undefined = 0x00000000
    Uint16 = 0x00000001
    Uint32 = 0x00000002


class LoadOp(IntEnum):
    Undefined = 0x00000000
    Clear = 0x00000001
    Load = 0x00000002


class MipmapFilterMode(IntEnum):
    Nearest = 0x00000000
    Linear = 0x00000001


class PowerPreference(IntEnum):
    Undefined = 0x00000000
    LowPower = 0x00000001
    HighPerformance = 0x00000002


class PresentMode(IntEnum):
    Fifo = 0x00000000
    FifoRelaxed = 0x00000001
    Immediate = 0x00000002
    Mailbox = 0x00000003


class PrimitiveTopology(IntEnum):
    PointList = 0x00000000
    LineList = 0x00000001
    LineStrip = 0x00000002
    TriangleList = 0x00000003
    TriangleStrip = 0x00000004


class QueryType(IntEnum):
    Occlusion = 0x00000000
    Timestamp = 0x00000001


class QueueWorkDoneStatus(IntEnum):
    Success = 0x00000000
    Error = 0x00000001
    Unknown = 0x00000002
    DeviceLost = 0x00000003


class RequestAdapterStatus(IntEnum):
    Success = 0x00000000
    Unavailable = 0x00000001
    Error = 0x00000002
    Unknown = 0x00000003


class RequestDeviceStatus(IntEnum):
    Success = 0x00000000
    Error = 0x00000001
    Unknown = 0x00000002


class SType(IntEnum):
    Invalid = 0x00000000
    SurfaceDescriptorFromMetalLayer = 0x00000001
    SurfaceDescriptorFromWindowsHWND = 0x00000002
    SurfaceDescriptorFromXlibWindow = 0x00000003
    SurfaceDescriptorFromCanvasHTMLSelector = 0x00000004
    ShaderModuleSPIRVDescriptor = 0x00000005
    ShaderModuleWGSLDescriptor = 0x00000006
    PrimitiveDepthClipControl = 0x00000007
    SurfaceDescriptorFromWaylandSurface = 0x00000008
    SurfaceDescriptorFromAndroidNativeWindow = 0x00000009
    SurfaceDescriptorFromXcbWindow = 0x0000000A
    RenderPassDescriptorMaxDrawCount = 0x0000000F
    DeviceExtras = 0x00030001
    RequiredLimitsExtras = 0x00030002
    PipelineLayoutExtras = 0x00030003
    ShaderModuleGLSLDescriptor = 0x00030004
    SupportedLimitsExtras = 0x00030005
    InstanceExtras = 0x00030006
    BindGroupEntryExtras = 0x00030007
    BindGroupLayoutEntryExtras = 0x00030008
    QuerySetDescriptorExtras = 0x00030009
    SurfaceConfigurationExtras = 0x0003000A


class SamplerBindingType(IntEnum):
    Undefined = 0x00000000
    Filtering = 0x00000001
    NonFiltering = 0x00000002
    Comparison = 0x00000003


class StencilOperation(IntEnum):
    Keep = 0x00000000
    Zero = 0x00000001
    Replace = 0x00000002
    Invert = 0x00000003
    IncrementClamp = 0x00000004
    DecrementClamp = 0x00000005
    IncrementWrap = 0x00000006
    DecrementWrap = 0x00000007


class StorageTextureAccess(IntEnum):
    Undefined = 0x00000000
    WriteOnly = 0x00000001
    ReadOnly = 0x00000002
    ReadWrite = 0x00000003


class StoreOp(IntEnum):
    Undefined = 0x00000000
    Store = 0x00000001
    Discard = 0x00000002


class SurfaceGetCurrentTextureStatus(IntEnum):
    Success = 0x00000000
    Timeout = 0x00000001
    Outdated = 0x00000002
    Lost = 0x00000003
    OutOfMemory = 0x00000004
    DeviceLost = 0x00000005


class TextureAspect(IntEnum):
    All = 0x00000000
    StencilOnly = 0x00000001
    DepthOnly = 0x00000002


class TextureDimension(IntEnum):
    _1D = 0x00000000
    _2D = 0x00000001
    _3D = 0x00000002


class TextureFormat(IntEnum):
    Undefined = 0x00000000
    R8Unorm = 0x00000001
    R8Snorm = 0x00000002
    R8Uint = 0x00000003
    R8Sint = 0x00000004
    R16Uint = 0x00000005
    R16Sint = 0x00000006
    R16Float = 0x00000007
    RG8Unorm = 0x00000008
    RG8Snorm = 0x00000009
    RG8Uint = 0x0000000A
    RG8Sint = 0x0000000B
    R32Float = 0x0000000C
    R32Uint = 0x0000000D
    R32Sint = 0x0000000E
    RG16Uint = 0x0000000F
    RG16Sint = 0x00000010
    RG16Float = 0x00000011
    RGBA8Unorm = 0x00000012
    RGBA8UnormSrgb = 0x00000013
    RGBA8Snorm = 0x00000014
    RGBA8Uint = 0x00000015
    RGBA8Sint = 0x00000016
    BGRA8Unorm = 0x00000017
    BGRA8UnormSrgb = 0x00000018
    RGB10A2Uint = 0x00000019
    RGB10A2Unorm = 0x0000001A
    RG11B10Ufloat = 0x0000001B
    RGB9E5Ufloat = 0x0000001C
    RG32Float = 0x0000001D
    RG32Uint = 0x0000001E
    RG32Sint = 0x0000001F
    RGBA16Uint = 0x00000020
    RGBA16Sint = 0x00000021
    RGBA16Float = 0x00000022
    RGBA32Float = 0x00000023
    RGBA32Uint = 0x00000024
    RGBA32Sint = 0x00000025
    Stencil8 = 0x00000026
    Depth16Unorm = 0x00000027
    Depth24Plus = 0x00000028
    Depth24PlusStencil8 = 0x00000029
    Depth32Float = 0x0000002A
    Depth32FloatStencil8 = 0x0000002B
    BC1RGBAUnorm = 0x0000002C
    BC1RGBAUnormSrgb = 0x0000002D
    BC2RGBAUnorm = 0x0000002E
    BC2RGBAUnormSrgb = 0x0000002F
    BC3RGBAUnorm = 0x00000030
    BC3RGBAUnormSrgb = 0x00000031
    BC4RUnorm = 0x00000032
    BC4RSnorm = 0x00000033
    BC5RGUnorm = 0x00000034
    BC5RGSnorm = 0x00000035
    BC6HRGBUfloat = 0x00000036
    BC6HRGBFloat = 0x00000037
    BC7RGBAUnorm = 0x00000038
    BC7RGBAUnormSrgb = 0x00000039
    ETC2RGB8Unorm = 0x0000003A
    ETC2RGB8UnormSrgb = 0x0000003B
    ETC2RGB8A1Unorm = 0x0000003C
    ETC2RGB8A1UnormSrgb = 0x0000003D
    ETC2RGBA8Unorm = 0x0000003E
    ETC2RGBA8UnormSrgb = 0x0000003F
    EACR11Unorm = 0x00000040
    EACR11Snorm = 0x00000041
    EACRG11Unorm = 0x00000042
    EACRG11Snorm = 0x00000043
    ASTC4x4Unorm = 0x00000044
    ASTC4x4UnormSrgb = 0x00000045
    ASTC5x4Unorm = 0x00000046
    ASTC5x4UnormSrgb = 0x00000047
    ASTC5x5Unorm = 0x00000048
    ASTC5x5UnormSrgb = 0x00000049
    ASTC6x5Unorm = 0x0000004A
    ASTC6x5UnormSrgb = 0x0000004B
    ASTC6x6Unorm = 0x0000004C
    ASTC6x6UnormSrgb = 0x0000004D
    ASTC8x5Unorm = 0x0000004E
    ASTC8x5UnormSrgb = 0x0000004F
    ASTC8x6Unorm = 0x00000050
    ASTC8x6UnormSrgb = 0x00000051
    ASTC8x8Unorm = 0x00000052
    ASTC8x8UnormSrgb = 0x00000053
    ASTC10x5Unorm = 0x00000054
    ASTC10x5UnormSrgb = 0x00000055
    ASTC10x6Unorm = 0x00000056
    ASTC10x6UnormSrgb = 0x00000057
    ASTC10x8Unorm = 0x00000058
    ASTC10x8UnormSrgb = 0x00000059
    ASTC10x10Unorm = 0x0000005A
    ASTC10x10UnormSrgb = 0x0000005B
    ASTC12x10Unorm = 0x0000005C
    ASTC12x10UnormSrgb = 0x0000005D
    ASTC12x12Unorm = 0x0000005E
    ASTC12x12UnormSrgb = 0x0000005F


class TextureSampleType(IntEnum):
    Undefined = 0x00000000
    Float = 0x00000001
    UnfilterableFloat = 0x00000002
    Depth = 0x00000003
    Sint = 0x00000004
    Uint = 0x00000005


class TextureViewDimension(IntEnum):
    Undefined = 0x00000000
    _1D = 0x00000001
    _2D = 0x00000002
    _2DArray = 0x00000003
    Cube = 0x00000004
    CubeArray = 0x00000005
    _3D = 0x00000006


class VertexFormat(IntEnum):
    Undefined = 0x00000000
    Uint8x2 = 0x00000001
    Uint8x4 = 0x00000002
    Sint8x2 = 0x00000003
    Sint8x4 = 0x00000004
    Unorm8x2 = 0x00000005
    Unorm8x4 = 0x00000006
    Snorm8x2 = 0x00000007
    Snorm8x4 = 0x00000008
    Uint16x2 = 0x00000009
    Uint16x4 = 0x0000000A
    Sint16x2 = 0x0000000B
    Sint16x4 = 0x0000000C
    Unorm16x2 = 0x0000000D
    Unorm16x4 = 0x0000000E
    Snorm16x2 = 0x0000000F
    Snorm16x4 = 0x00000010
    Float16x2 = 0x00000011
    Float16x4 = 0x00000012
    Float32 = 0x00000013
    Float32x2 = 0x00000014
    Float32x3 = 0x00000015
    Float32x4 = 0x00000016
    Uint32 = 0x00000017
    Uint32x2 = 0x00000018
    Uint32x3 = 0x00000019
    Uint32x4 = 0x0000001A
    Sint32 = 0x0000001B
    Sint32x2 = 0x0000001C
    Sint32x3 = 0x0000001D
    Sint32x4 = 0x0000001E


class VertexStepMode(IntEnum):
    Vertex = 0x00000000
    Instance = 0x00000001
    VertexBufferNotUsed = 0x00000002


class WGSLFeatureName(IntEnum):
    Undefined = 0x00000000
    ReadonlyAndReadwriteStorageTextures = 0x00000001
    Packed4x8IntegerDotProduct = 0x00000002
    UnrestrictedPointerParameters = 0x00000003
    PointerCompositeAccess = 0x00000004


class BufferUsage(IntEnum):
    _None = 0x00000000
    MapRead = 0x00000001
    MapWrite = 0x00000002
    CopySrc = 0x00000004
    CopyDst = 0x00000008
    Index = 0x00000010
    Vertex = 0x00000020
    Uniform = 0x00000040
    Storage = 0x00000080
    Indirect = 0x00000100
    QueryResolve = 0x00000200

    def asflag(self) -> "BufferUsageFlags":
        return BufferUsageFlags(self)


class ColorWriteMask(IntEnum):
    _None = 0x00000000
    Red = 0x00000001
    Green = 0x00000002
    Blue = 0x00000004
    Alpha = 0x00000008
    All = 0x0000000F

    def asflag(self) -> "ColorWriteMaskFlags":
        return ColorWriteMaskFlags(self)


class MapMode(IntEnum):
    _None = 0x00000000
    Read = 0x00000001
    Write = 0x00000002

    def asflag(self) -> "MapModeFlags":
        return MapModeFlags(self)


class ShaderStage(IntEnum):
    _None = 0x00000000
    Vertex = 0x00000001
    Fragment = 0x00000002
    Compute = 0x00000004

    def asflag(self) -> "ShaderStageFlags":
        return ShaderStageFlags(self)


class TextureUsage(IntEnum):
    _None = 0x00000000
    CopySrc = 0x00000001
    CopyDst = 0x00000002
    TextureBinding = 0x00000004
    StorageBinding = 0x00000008
    RenderAttachment = 0x00000010

    def asflag(self) -> "TextureUsageFlags":
        return TextureUsageFlags(self)


class LogLevel(IntEnum):
    Off = 0x00000000
    Error = 0x00000001
    Warn = 0x00000002
    Info = 0x00000003
    Debug = 0x00000004
    Trace = 0x00000005


class InstanceBackend(IntEnum):
    All = 0x00000000
    Vulkan = 0x00000001
    GL = 0x00000002
    Metal = 0x00000004
    DX12 = 0x00000008
    DX11 = 0x00000010
    BrowserWebGPU = 0x00000020
    Primary = 0x0000002D
    Secondary = 0x00000012

    def asflag(self) -> "InstanceBackendFlags":
        return InstanceBackendFlags(self)


class InstanceFlag(IntEnum):
    Default = 0x00000000
    Debug = 0x00000001
    Validation = 0x00000002
    DiscardHalLabels = 0x00000004

    def asflag(self) -> "InstanceFlags":
        return InstanceFlags(self)


class Dx12Compiler(IntEnum):
    Undefined = 0x00000000
    Fxc = 0x00000001
    Dxc = 0x00000002


class Gles3MinorVersion(IntEnum):
    Automatic = 0x00000000
    Version0 = 0x00000001
    Version1 = 0x00000002
    Version2 = 0x00000003


class PipelineStatisticName(IntEnum):
    VertexShaderInvocations = 0x00000000
    ClipperInvocations = 0x00000001
    ClipperPrimitivesOut = 0x00000002
    FragmentShaderInvocations = 0x00000003
    ComputeShaderInvocations = 0x00000004


class NativeQueryType(IntEnum):
    PipelineStatistics = 0x00030000


class NativeTextureFormat(IntEnum):
    R16Unorm = 0x00030001
    R16Snorm = 0x00030002
    Rg16Unorm = 0x00030003
    Rg16Snorm = 0x00030004
    Rgba16Unorm = 0x00030005
    Rgba16Snorm = 0x00030006
    NV12 = 0x00030007


class BufferUsageFlags:
    def __init__(self, flags: Union[List["BufferUsage"], int, "BufferUsageFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(self, rhs: Union["BufferUsageFlags", "BufferUsage"]) -> "BufferUsageFlags":
        return BufferUsageFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "BufferUsage") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["BufferUsage"]:
        if self.value == 0:
            yield BufferUsage(0)
            return
        for v in BufferUsage:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("BufferUsage." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class ColorWriteMaskFlags:
    def __init__(self, flags: Union[List["ColorWriteMask"], int, "ColorWriteMaskFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(
        self, rhs: Union["ColorWriteMaskFlags", "ColorWriteMask"]
    ) -> "ColorWriteMaskFlags":
        return ColorWriteMaskFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "ColorWriteMask") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["ColorWriteMask"]:
        if self.value == 0:
            yield ColorWriteMask(0)
            return
        for v in ColorWriteMask:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("ColorWriteMask." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class MapModeFlags:
    def __init__(self, flags: Union[List["MapMode"], int, "MapModeFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(self, rhs: Union["MapModeFlags", "MapMode"]) -> "MapModeFlags":
        return MapModeFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "MapMode") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["MapMode"]:
        if self.value == 0:
            yield MapMode(0)
            return
        for v in MapMode:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("MapMode." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class ShaderStageFlags:
    def __init__(self, flags: Union[List["ShaderStage"], int, "ShaderStageFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(self, rhs: Union["ShaderStageFlags", "ShaderStage"]) -> "ShaderStageFlags":
        return ShaderStageFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "ShaderStage") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["ShaderStage"]:
        if self.value == 0:
            yield ShaderStage(0)
            return
        for v in ShaderStage:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("ShaderStage." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class TextureUsageFlags:
    def __init__(self, flags: Union[List["TextureUsage"], int, "TextureUsageFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(
        self, rhs: Union["TextureUsageFlags", "TextureUsage"]
    ) -> "TextureUsageFlags":
        return TextureUsageFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "TextureUsage") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["TextureUsage"]:
        if self.value == 0:
            yield TextureUsage(0)
            return
        for v in TextureUsage:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("TextureUsage." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class InstanceBackendFlags:
    def __init__(
        self, flags: Union[List["InstanceBackend"], int, "InstanceBackendFlags"]
    ):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(
        self, rhs: Union["InstanceBackendFlags", "InstanceBackend"]
    ) -> "InstanceBackendFlags":
        return InstanceBackendFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "InstanceBackend") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["InstanceBackend"]:
        if self.value == 0:
            yield InstanceBackend(0)
            return
        for v in InstanceBackend:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("InstanceBackend." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class InstanceFlags:
    def __init__(self, flags: Union[List["InstanceFlag"], int, "InstanceFlags"]):
        if isinstance(flags, list):
            self.value = sum(set(flags))
        else:
            self.value = int(flags)

    def __or__(self, rhs: Union["InstanceFlags", "InstanceFlag"]) -> "InstanceFlags":
        return InstanceFlags(int(self) | int(rhs))

    def __int__(self) -> int:
        return self.value

    def __contains__(self, flag: "InstanceFlag") -> bool:
        return self.value & int(flag) > 0

    def __iter__(self) -> Iterator["InstanceFlag"]:
        if self.value == 0:
            yield InstanceFlag(0)
            return
        for v in InstanceFlag:
            if self.value & int(v) > 0:
                yield v

    def __str__(self) -> str:
        return " | ".join("InstanceFlag." + v.name for v in self)

    def __repr__(self) -> str:
        return str(self)


class Adapter:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuAdapterRelease)
            if add_ref:
                lib.wgpuAdapterReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuAdapterRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def enumerateFeatures(self) -> List["FeatureName"]:
        # Hand-written because of idiosyncratic convention for using this function
        feature_count = lib.wgpuAdapterEnumerateFeatures(self._cdata, ffi.NULL)
        feature_list = ffi.new("WGPUFeatureName[]", feature_count)
        lib.wgpuAdapterEnumerateFeatures(self._cdata, feature_list)
        return [FeatureName(feature_list[idx]) for idx in range(feature_count)]

    def getInfo(self, info: "AdapterInfo") -> None:
        return lib.wgpuAdapterGetInfo(self._cdata, info._cdata)

    def getLimits(self, limits: "SupportedLimits") -> bool:
        return lib.wgpuAdapterGetLimits(self._cdata, limits._cdata)

    def hasFeature(self, feature: "FeatureName") -> bool:
        return lib.wgpuAdapterHasFeature(self._cdata, int(feature))

    def requestDevice(
        self,
        descriptor: Optional["DeviceDescriptor"],
        callback: "AdapterRequestDeviceCallback",
    ) -> None:
        return lib.wgpuAdapterRequestDevice(
            self._cdata,
            _ffi_unwrap_optional(descriptor),
            callback._ptr,
            callback._userdata,
        )

    def _reference(self) -> None:
        return lib.wgpuAdapterReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuAdapterRelease(self._cdata)


class BindGroup:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuBindGroupRelease)
            if add_ref:
                lib.wgpuBindGroupReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuBindGroupRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuBindGroupSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuBindGroupReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuBindGroupRelease(self._cdata)


class BindGroupLayout:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuBindGroupLayoutRelease)
            if add_ref:
                lib.wgpuBindGroupLayoutReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuBindGroupLayoutRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuBindGroupLayoutSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuBindGroupLayoutReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuBindGroupLayoutRelease(self._cdata)


class Buffer:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuBufferRelease)
            if add_ref:
                lib.wgpuBufferReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuBufferRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def destroy(self) -> None:
        return lib.wgpuBufferDestroy(self._cdata)

    def getConstMappedRange(self, offset: int, size: int) -> DataPtr:
        return DataPtr(lib.wgpuBufferGetConstMappedRange(self._cdata, offset, size), size)

    def getMapState(self) -> "BufferMapState":
        return BufferMapState(lib.wgpuBufferGetMapState(self._cdata))

    def getMappedRange(self, offset: int, size: int) -> DataPtr:
        return DataPtr(lib.wgpuBufferGetMappedRange(self._cdata, offset, size), size)

    def getSize(self) -> int:
        return lib.wgpuBufferGetSize(self._cdata)

    def getUsage(self) -> "BufferUsageFlags":
        return BufferUsageFlags(lib.wgpuBufferGetUsage(self._cdata))

    def mapAsync(
        self,
        mode: Union["MapModeFlags", "MapMode", int],
        offset: int,
        size: int,
        callback: "BufferMapAsyncCallback",
    ) -> None:
        return lib.wgpuBufferMapAsync(
            self._cdata, int(mode), offset, size, callback._ptr, callback._userdata
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuBufferSetLabel(self._cdata, _ffi_unwrap_str(label))

    def unmap(self) -> None:
        return lib.wgpuBufferUnmap(self._cdata)

    def _reference(self) -> None:
        return lib.wgpuBufferReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuBufferRelease(self._cdata)


class CommandBuffer:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuCommandBufferRelease)
            if add_ref:
                lib.wgpuCommandBufferReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuCommandBufferRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuCommandBufferSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuCommandBufferReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuCommandBufferRelease(self._cdata)


class CommandEncoder:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuCommandEncoderRelease)
            if add_ref:
                lib.wgpuCommandEncoderReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuCommandEncoderRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def beginComputePassFromDesc(
        self, descriptor: Optional["ComputePassDescriptor"]
    ) -> "ComputePassEncoder":
        return ComputePassEncoder(
            lib.wgpuCommandEncoderBeginComputePass(
                self._cdata, _ffi_unwrap_optional(descriptor)
            ),
            add_ref=False,
        )

    def beginComputePass(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        timestampWrites: Optional["ComputePassTimestampWrites"] = None,
    ) -> "ComputePassEncoder":
        return self.beginComputePassFromDesc(
            computePassDescriptor(
                nextInChain=nextInChain, label=label, timestampWrites=timestampWrites
            )
        )

    def beginRenderPassFromDesc(
        self, descriptor: "RenderPassDescriptor"
    ) -> "RenderPassEncoder":
        return RenderPassEncoder(
            lib.wgpuCommandEncoderBeginRenderPass(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def beginRenderPass(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        colorAttachments: Union[
            "RenderPassColorAttachmentList", List["RenderPassColorAttachment"]
        ],
        depthStencilAttachment: Optional["RenderPassDepthStencilAttachment"] = None,
        occlusionQuerySet: Optional["QuerySet"] = None,
        timestampWrites: Optional["RenderPassTimestampWrites"] = None,
    ) -> "RenderPassEncoder":
        return self.beginRenderPassFromDesc(
            renderPassDescriptor(
                nextInChain=nextInChain,
                label=label,
                colorAttachments=colorAttachments,
                depthStencilAttachment=depthStencilAttachment,
                occlusionQuerySet=occlusionQuerySet,
                timestampWrites=timestampWrites,
            )
        )

    def clearBuffer(self, buffer: "Buffer", offset: int, size: int) -> None:
        return lib.wgpuCommandEncoderClearBuffer(self._cdata, buffer._cdata, offset, size)

    def copyBufferToBuffer(
        self,
        source: "Buffer",
        sourceOffset: int,
        destination: "Buffer",
        destinationOffset: int,
        size: int,
    ) -> None:
        return lib.wgpuCommandEncoderCopyBufferToBuffer(
            self._cdata,
            source._cdata,
            sourceOffset,
            destination._cdata,
            destinationOffset,
            size,
        )

    def copyBufferToTexture(
        self,
        source: "ImageCopyBuffer",
        destination: "ImageCopyTexture",
        copySize: "Extent3D",
    ) -> None:
        return lib.wgpuCommandEncoderCopyBufferToTexture(
            self._cdata, source._cdata, destination._cdata, copySize._cdata
        )

    def copyTextureToBuffer(
        self,
        source: "ImageCopyTexture",
        destination: "ImageCopyBuffer",
        copySize: "Extent3D",
    ) -> None:
        return lib.wgpuCommandEncoderCopyTextureToBuffer(
            self._cdata, source._cdata, destination._cdata, copySize._cdata
        )

    def copyTextureToTexture(
        self,
        source: "ImageCopyTexture",
        destination: "ImageCopyTexture",
        copySize: "Extent3D",
    ) -> None:
        return lib.wgpuCommandEncoderCopyTextureToTexture(
            self._cdata, source._cdata, destination._cdata, copySize._cdata
        )

    def finishFromDesc(
        self, descriptor: Optional["CommandBufferDescriptor"]
    ) -> "CommandBuffer":
        return CommandBuffer(
            lib.wgpuCommandEncoderFinish(self._cdata, _ffi_unwrap_optional(descriptor)),
            add_ref=False,
        )

    def finish(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
    ) -> "CommandBuffer":
        return self.finishFromDesc(
            commandBufferDescriptor(nextInChain=nextInChain, label=label)
        )

    def insertDebugMarker(self, markerLabel: str) -> None:
        return lib.wgpuCommandEncoderInsertDebugMarker(
            self._cdata, _ffi_unwrap_str(markerLabel)
        )

    def popDebugGroup(self) -> None:
        return lib.wgpuCommandEncoderPopDebugGroup(self._cdata)

    def pushDebugGroup(self, groupLabel: str) -> None:
        return lib.wgpuCommandEncoderPushDebugGroup(
            self._cdata, _ffi_unwrap_str(groupLabel)
        )

    def resolveQuerySet(
        self,
        querySet: "QuerySet",
        firstQuery: int,
        queryCount: int,
        destination: "Buffer",
        destinationOffset: int,
    ) -> None:
        return lib.wgpuCommandEncoderResolveQuerySet(
            self._cdata,
            querySet._cdata,
            firstQuery,
            queryCount,
            destination._cdata,
            destinationOffset,
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuCommandEncoderSetLabel(self._cdata, _ffi_unwrap_str(label))

    def writeTimestamp(self, querySet: "QuerySet", queryIndex: int) -> None:
        return lib.wgpuCommandEncoderWriteTimestamp(
            self._cdata, querySet._cdata, queryIndex
        )

    def _reference(self) -> None:
        return lib.wgpuCommandEncoderReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuCommandEncoderRelease(self._cdata)


class ComputePassEncoder:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuComputePassEncoderRelease)
            if add_ref:
                lib.wgpuComputePassEncoderReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuComputePassEncoderRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def dispatchWorkgroups(
        self, workgroupCountX: int, workgroupCountY: int, workgroupCountZ: int
    ) -> None:
        return lib.wgpuComputePassEncoderDispatchWorkgroups(
            self._cdata, workgroupCountX, workgroupCountY, workgroupCountZ
        )

    def dispatchWorkgroupsIndirect(
        self, indirectBuffer: "Buffer", indirectOffset: int
    ) -> None:
        return lib.wgpuComputePassEncoderDispatchWorkgroupsIndirect(
            self._cdata, indirectBuffer._cdata, indirectOffset
        )

    def end(self) -> None:
        ret = lib.wgpuComputePassEncoderEnd(self._cdata)
        self.release()
        return ret

    def insertDebugMarker(self, markerLabel: str) -> None:
        return lib.wgpuComputePassEncoderInsertDebugMarker(
            self._cdata, _ffi_unwrap_str(markerLabel)
        )

    def popDebugGroup(self) -> None:
        return lib.wgpuComputePassEncoderPopDebugGroup(self._cdata)

    def pushDebugGroup(self, groupLabel: str) -> None:
        return lib.wgpuComputePassEncoderPushDebugGroup(
            self._cdata, _ffi_unwrap_str(groupLabel)
        )

    def setBindGroup(
        self,
        groupIndex: int,
        group: Optional["BindGroup"],
        dynamicOffsets: Union["IntList", List[int]],
    ) -> None:
        if isinstance(dynamicOffsets, list):
            dynamicOffsets_staged = IntList(dynamicOffsets)
        else:
            dynamicOffsets_staged = dynamicOffsets
        return lib.wgpuComputePassEncoderSetBindGroup(
            self._cdata,
            groupIndex,
            _ffi_unwrap_optional(group),
            dynamicOffsets_staged._count,
            dynamicOffsets_staged._ptr,
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuComputePassEncoderSetLabel(self._cdata, _ffi_unwrap_str(label))

    def setPipeline(self, pipeline: "ComputePipeline") -> None:
        return lib.wgpuComputePassEncoderSetPipeline(self._cdata, pipeline._cdata)

    def _reference(self) -> None:
        return lib.wgpuComputePassEncoderReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuComputePassEncoderRelease(self._cdata)

    def beginPipelineStatisticsQuery(self, querySet: "QuerySet", queryIndex: int) -> None:
        return lib.wgpuComputePassEncoderBeginPipelineStatisticsQuery(
            self._cdata, querySet._cdata, queryIndex
        )

    def endPipelineStatisticsQuery(self) -> None:
        return lib.wgpuComputePassEncoderEndPipelineStatisticsQuery(self._cdata)


class ComputePipeline:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuComputePipelineRelease)
            if add_ref:
                lib.wgpuComputePipelineReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuComputePipelineRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def getBindGroupLayout(self, groupIndex: int) -> "BindGroupLayout":
        return BindGroupLayout(
            lib.wgpuComputePipelineGetBindGroupLayout(self._cdata, groupIndex),
            add_ref=False,
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuComputePipelineSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuComputePipelineReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuComputePipelineRelease(self._cdata)


class Device:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuDeviceRelease)
            if add_ref:
                lib.wgpuDeviceReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuDeviceRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def getProcAddress(self, procName: str) -> VoidPtr:
        return VoidPtr(lib.wgpuGetProcAddress(self._cdata, _ffi_unwrap_str(procName)))

    def createBindGroupFromDesc(self, descriptor: "BindGroupDescriptor") -> "BindGroup":
        return BindGroup(
            lib.wgpuDeviceCreateBindGroup(self._cdata, descriptor._cdata), add_ref=False
        )

    def createBindGroup(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        layout: "BindGroupLayout",
        entries: Union["BindGroupEntryList", List["BindGroupEntry"]],
    ) -> "BindGroup":
        return self.createBindGroupFromDesc(
            bindGroupDescriptor(
                nextInChain=nextInChain, label=label, layout=layout, entries=entries
            )
        )

    def createBindGroupLayoutFromDesc(
        self, descriptor: "BindGroupLayoutDescriptor"
    ) -> "BindGroupLayout":
        return BindGroupLayout(
            lib.wgpuDeviceCreateBindGroupLayout(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createBindGroupLayout(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        entries: Union["BindGroupLayoutEntryList", List["BindGroupLayoutEntry"]],
    ) -> "BindGroupLayout":
        return self.createBindGroupLayoutFromDesc(
            bindGroupLayoutDescriptor(
                nextInChain=nextInChain, label=label, entries=entries
            )
        )

    def createBufferFromDesc(self, descriptor: "BufferDescriptor") -> "Buffer":
        return Buffer(
            lib.wgpuDeviceCreateBuffer(self._cdata, descriptor._cdata), add_ref=False
        )

    def createBuffer(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        usage: Union["BufferUsageFlags", "BufferUsage", int],
        size: int,
        mappedAtCreation: bool = False,
    ) -> "Buffer":
        return self.createBufferFromDesc(
            bufferDescriptor(
                nextInChain=nextInChain,
                label=label,
                usage=usage,
                size=size,
                mappedAtCreation=mappedAtCreation,
            )
        )

    def createCommandEncoderFromDesc(
        self, descriptor: Optional["CommandEncoderDescriptor"]
    ) -> "CommandEncoder":
        return CommandEncoder(
            lib.wgpuDeviceCreateCommandEncoder(
                self._cdata, _ffi_unwrap_optional(descriptor)
            ),
            add_ref=False,
        )

    def createCommandEncoder(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
    ) -> "CommandEncoder":
        return self.createCommandEncoderFromDesc(
            commandEncoderDescriptor(nextInChain=nextInChain, label=label)
        )

    def createComputePipelineFromDesc(
        self, descriptor: "ComputePipelineDescriptor"
    ) -> "ComputePipeline":
        return ComputePipeline(
            lib.wgpuDeviceCreateComputePipeline(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createComputePipeline(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        layout: Optional["PipelineLayout"] = None,
        compute: "ProgrammableStageDescriptor",
    ) -> "ComputePipeline":
        return self.createComputePipelineFromDesc(
            computePipelineDescriptor(
                nextInChain=nextInChain, label=label, layout=layout, compute=compute
            )
        )

    def createComputePipelineAsync(
        self,
        descriptor: "ComputePipelineDescriptor",
        callback: "DeviceCreateComputePipelineAsyncCallback",
    ) -> None:
        return lib.wgpuDeviceCreateComputePipelineAsync(
            self._cdata, descriptor._cdata, callback._ptr, callback._userdata
        )

    def createPipelineLayoutFromDesc(
        self, descriptor: "PipelineLayoutDescriptor"
    ) -> "PipelineLayout":
        return PipelineLayout(
            lib.wgpuDeviceCreatePipelineLayout(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createPipelineLayout(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        bindGroupLayouts: Union["BindGroupLayoutList", List["BindGroupLayout"]],
    ) -> "PipelineLayout":
        return self.createPipelineLayoutFromDesc(
            pipelineLayoutDescriptor(
                nextInChain=nextInChain, label=label, bindGroupLayouts=bindGroupLayouts
            )
        )

    def createQuerySetFromDesc(self, descriptor: "QuerySetDescriptor") -> "QuerySet":
        return QuerySet(
            lib.wgpuDeviceCreateQuerySet(self._cdata, descriptor._cdata), add_ref=False
        )

    def createQuerySet(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        type: "QueryType",
        count: int,
    ) -> "QuerySet":
        return self.createQuerySetFromDesc(
            querySetDescriptor(
                nextInChain=nextInChain, label=label, type=type, count=count
            )
        )

    def createRenderBundleEncoderFromDesc(
        self, descriptor: "RenderBundleEncoderDescriptor"
    ) -> "RenderBundleEncoder":
        return RenderBundleEncoder(
            lib.wgpuDeviceCreateRenderBundleEncoder(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createRenderBundleEncoder(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        colorFormats: Union["TextureFormatList", List["TextureFormat"]],
        depthStencilFormat: "TextureFormat",
        sampleCount: int,
        depthReadOnly: bool = False,
        stencilReadOnly: bool = False,
    ) -> "RenderBundleEncoder":
        return self.createRenderBundleEncoderFromDesc(
            renderBundleEncoderDescriptor(
                nextInChain=nextInChain,
                label=label,
                colorFormats=colorFormats,
                depthStencilFormat=depthStencilFormat,
                sampleCount=sampleCount,
                depthReadOnly=depthReadOnly,
                stencilReadOnly=stencilReadOnly,
            )
        )

    def createRenderPipelineFromDesc(
        self, descriptor: "RenderPipelineDescriptor"
    ) -> "RenderPipeline":
        return RenderPipeline(
            lib.wgpuDeviceCreateRenderPipeline(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createRenderPipeline(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        layout: Optional["PipelineLayout"] = None,
        vertex: "VertexState",
        primitive: "PrimitiveState",
        depthStencil: Optional["DepthStencilState"] = None,
        multisample: "MultisampleState",
        fragment: Optional["FragmentState"] = None,
    ) -> "RenderPipeline":
        return self.createRenderPipelineFromDesc(
            renderPipelineDescriptor(
                nextInChain=nextInChain,
                label=label,
                layout=layout,
                vertex=vertex,
                primitive=primitive,
                depthStencil=depthStencil,
                multisample=multisample,
                fragment=fragment,
            )
        )

    def createRenderPipelineAsync(
        self,
        descriptor: "RenderPipelineDescriptor",
        callback: "DeviceCreateRenderPipelineAsyncCallback",
    ) -> None:
        return lib.wgpuDeviceCreateRenderPipelineAsync(
            self._cdata, descriptor._cdata, callback._ptr, callback._userdata
        )

    def createSamplerFromDesc(
        self, descriptor: Optional["SamplerDescriptor"]
    ) -> "Sampler":
        return Sampler(
            lib.wgpuDeviceCreateSampler(self._cdata, _ffi_unwrap_optional(descriptor)),
            add_ref=False,
        )

    def createSampler(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        addressModeU: "AddressMode" = AddressMode.ClampToEdge,
        addressModeV: "AddressMode" = AddressMode.ClampToEdge,
        addressModeW: "AddressMode" = AddressMode.ClampToEdge,
        magFilter: "FilterMode" = FilterMode.Nearest,
        minFilter: "FilterMode" = FilterMode.Nearest,
        mipmapFilter: "MipmapFilterMode" = MipmapFilterMode.Nearest,
        lodMinClamp: float = 0,
        lodMaxClamp: float = 32,
        compare: "CompareFunction",
        maxAnisotropy: int = 1,
    ) -> "Sampler":
        return self.createSamplerFromDesc(
            samplerDescriptor(
                nextInChain=nextInChain,
                label=label,
                addressModeU=addressModeU,
                addressModeV=addressModeV,
                addressModeW=addressModeW,
                magFilter=magFilter,
                minFilter=minFilter,
                mipmapFilter=mipmapFilter,
                lodMinClamp=lodMinClamp,
                lodMaxClamp=lodMaxClamp,
                compare=compare,
                maxAnisotropy=maxAnisotropy,
            )
        )

    def createShaderModuleFromDesc(
        self, descriptor: "ShaderModuleDescriptor"
    ) -> "ShaderModule":
        return ShaderModule(
            lib.wgpuDeviceCreateShaderModule(self._cdata, descriptor._cdata),
            add_ref=False,
        )

    def createShaderModule(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        hints: Union[
            "ShaderModuleCompilationHintList", List["ShaderModuleCompilationHint"]
        ],
    ) -> "ShaderModule":
        return self.createShaderModuleFromDesc(
            shaderModuleDescriptor(nextInChain=nextInChain, label=label, hints=hints)
        )

    def createTextureFromDesc(self, descriptor: "TextureDescriptor") -> "Texture":
        return Texture(
            lib.wgpuDeviceCreateTexture(self._cdata, descriptor._cdata), add_ref=False
        )

    def createTexture(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        usage: Union["TextureUsageFlags", "TextureUsage", int],
        dimension: "TextureDimension" = TextureDimension._2D,
        size: "Extent3D",
        format: "TextureFormat",
        mipLevelCount: int = 1,
        sampleCount: int = 1,
        viewFormats: Union["TextureFormatList", List["TextureFormat"]],
    ) -> "Texture":
        return self.createTextureFromDesc(
            textureDescriptor(
                nextInChain=nextInChain,
                label=label,
                usage=usage,
                dimension=dimension,
                size=size,
                format=format,
                mipLevelCount=mipLevelCount,
                sampleCount=sampleCount,
                viewFormats=viewFormats,
            )
        )

    def destroy(self) -> None:
        return lib.wgpuDeviceDestroy(self._cdata)

    def enumerateFeatures(self) -> List["FeatureName"]:
        # Hand-written because of idiosyncratic convention for using this function
        feature_count = lib.wgpuDeviceEnumerateFeatures(self._cdata, ffi.NULL)
        feature_list = ffi.new("WGPUFeatureName[]", feature_count)
        lib.wgpuDeviceEnumerateFeatures(self._cdata, feature_list)
        return [FeatureName(feature_list[idx]) for idx in range(feature_count)]

    def getLimits(self, limits: "SupportedLimits") -> bool:
        return lib.wgpuDeviceGetLimits(self._cdata, limits._cdata)

    def getQueue(self) -> "Queue":
        return Queue(lib.wgpuDeviceGetQueue(self._cdata), add_ref=False)

    def hasFeature(self, feature: "FeatureName") -> bool:
        return lib.wgpuDeviceHasFeature(self._cdata, int(feature))

    def popErrorScope(self, callback: "ErrorCallback") -> None:
        return lib.wgpuDevicePopErrorScope(self._cdata, callback._ptr, callback._userdata)

    def pushErrorScope(self, filter: "ErrorFilter") -> None:
        return lib.wgpuDevicePushErrorScope(self._cdata, int(filter))

    def setLabel(self, label: str) -> None:
        return lib.wgpuDeviceSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuDeviceReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuDeviceRelease(self._cdata)

    def poll(
        self, wait: bool, wrappedSubmissionIndex: Optional["WrappedSubmissionIndex"]
    ) -> bool:
        return lib.wgpuDevicePoll(
            self._cdata, wait, _ffi_unwrap_optional(wrappedSubmissionIndex)
        )


class Instance:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuInstanceRelease)
            if add_ref:
                lib.wgpuInstanceReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuInstanceRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def createSurfaceFromDesc(self, descriptor: "SurfaceDescriptor") -> "Surface":
        return Surface(
            lib.wgpuInstanceCreateSurface(self._cdata, descriptor._cdata), add_ref=False
        )

    def createSurface(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
    ) -> "Surface":
        return self.createSurfaceFromDesc(
            surfaceDescriptor(nextInChain=nextInChain, label=label)
        )

    def hasWGSLLanguageFeature(self, feature: "WGSLFeatureName") -> bool:
        return lib.wgpuInstanceHasWGSLLanguageFeature(self._cdata, int(feature))

    def processEvents(self) -> None:
        return lib.wgpuInstanceProcessEvents(self._cdata)

    def requestAdapter(
        self,
        options: Optional["RequestAdapterOptions"],
        callback: "InstanceRequestAdapterCallback",
    ) -> None:
        return lib.wgpuInstanceRequestAdapter(
            self._cdata, _ffi_unwrap_optional(options), callback._ptr, callback._userdata
        )

    def _reference(self) -> None:
        return lib.wgpuInstanceReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuInstanceRelease(self._cdata)

    def generateReport(self, report: "GlobalReport") -> None:
        return lib.wgpuGenerateReport(self._cdata, report._cdata)

    def enumerateAdapters(
        self, options: Optional["InstanceEnumerateAdapterOptions"], adapters: "Adapter"
    ) -> int:
        return lib.wgpuInstanceEnumerateAdapters(
            self._cdata, _ffi_unwrap_optional(options), adapters._cdata
        )


class PipelineLayout:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuPipelineLayoutRelease)
            if add_ref:
                lib.wgpuPipelineLayoutReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuPipelineLayoutRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuPipelineLayoutSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuPipelineLayoutReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuPipelineLayoutRelease(self._cdata)


class QuerySet:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuQuerySetRelease)
            if add_ref:
                lib.wgpuQuerySetReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuQuerySetRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def destroy(self) -> None:
        return lib.wgpuQuerySetDestroy(self._cdata)

    def getCount(self) -> int:
        return lib.wgpuQuerySetGetCount(self._cdata)

    def getType(self) -> "QueryType":
        return QueryType(lib.wgpuQuerySetGetType(self._cdata))

    def setLabel(self, label: str) -> None:
        return lib.wgpuQuerySetSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuQuerySetReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuQuerySetRelease(self._cdata)


class Queue:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuQueueRelease)
            if add_ref:
                lib.wgpuQueueReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuQueueRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def onSubmittedWorkDone(self, callback: "QueueOnSubmittedWorkDoneCallback") -> None:
        return lib.wgpuQueueOnSubmittedWorkDone(
            self._cdata, callback._ptr, callback._userdata
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuQueueSetLabel(self._cdata, _ffi_unwrap_str(label))

    def submit(self, commands: Union["CommandBufferList", List[CommandBuffer]]) -> None:
        if isinstance(commands, list):
            commands_staged = CommandBufferList(commands)
        else:
            commands_staged = commands
        return lib.wgpuQueueSubmit(
            self._cdata, commands_staged._count, commands_staged._ptr
        )

    def writeBuffer(self, buffer: "Buffer", bufferOffset: int, data: DataPtr) -> None:
        return lib.wgpuQueueWriteBuffer(
            self._cdata, buffer._cdata, bufferOffset, data._ptr, data._size
        )

    def writeTexture(
        self,
        destination: "ImageCopyTexture",
        data: DataPtr,
        dataLayout: "TextureDataLayout",
        writeSize: "Extent3D",
    ) -> None:
        return lib.wgpuQueueWriteTexture(
            self._cdata,
            destination._cdata,
            data._ptr,
            data._size,
            dataLayout._cdata,
            writeSize._cdata,
        )

    def _reference(self) -> None:
        return lib.wgpuQueueReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuQueueRelease(self._cdata)

    def submitForIndex(
        self, commands: Union["CommandBufferList", List[CommandBuffer]]
    ) -> int:
        if isinstance(commands, list):
            commands_staged = CommandBufferList(commands)
        else:
            commands_staged = commands
        return lib.wgpuQueueSubmitForIndex(
            self._cdata, commands_staged._count, commands_staged._ptr
        )


class RenderBundle:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuRenderBundleRelease)
            if add_ref:
                lib.wgpuRenderBundleReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuRenderBundleRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuRenderBundleSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuRenderBundleReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuRenderBundleRelease(self._cdata)


class RenderBundleEncoder:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuRenderBundleEncoderRelease)
            if add_ref:
                lib.wgpuRenderBundleEncoderReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuRenderBundleEncoderRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def draw(
        self, vertexCount: int, instanceCount: int, firstVertex: int, firstInstance: int
    ) -> None:
        return lib.wgpuRenderBundleEncoderDraw(
            self._cdata, vertexCount, instanceCount, firstVertex, firstInstance
        )

    def drawIndexed(
        self,
        indexCount: int,
        instanceCount: int,
        firstIndex: int,
        baseVertex: int,
        firstInstance: int,
    ) -> None:
        return lib.wgpuRenderBundleEncoderDrawIndexed(
            self._cdata, indexCount, instanceCount, firstIndex, baseVertex, firstInstance
        )

    def drawIndexedIndirect(self, indirectBuffer: "Buffer", indirectOffset: int) -> None:
        return lib.wgpuRenderBundleEncoderDrawIndexedIndirect(
            self._cdata, indirectBuffer._cdata, indirectOffset
        )

    def drawIndirect(self, indirectBuffer: "Buffer", indirectOffset: int) -> None:
        return lib.wgpuRenderBundleEncoderDrawIndirect(
            self._cdata, indirectBuffer._cdata, indirectOffset
        )

    def finishFromDesc(
        self, descriptor: Optional["RenderBundleDescriptor"]
    ) -> "RenderBundle":
        return RenderBundle(
            lib.wgpuRenderBundleEncoderFinish(
                self._cdata, _ffi_unwrap_optional(descriptor)
            ),
            add_ref=False,
        )

    def finish(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
    ) -> "RenderBundle":
        return self.finishFromDesc(
            renderBundleDescriptor(nextInChain=nextInChain, label=label)
        )

    def insertDebugMarker(self, markerLabel: str) -> None:
        return lib.wgpuRenderBundleEncoderInsertDebugMarker(
            self._cdata, _ffi_unwrap_str(markerLabel)
        )

    def popDebugGroup(self) -> None:
        return lib.wgpuRenderBundleEncoderPopDebugGroup(self._cdata)

    def pushDebugGroup(self, groupLabel: str) -> None:
        return lib.wgpuRenderBundleEncoderPushDebugGroup(
            self._cdata, _ffi_unwrap_str(groupLabel)
        )

    def setBindGroup(
        self,
        groupIndex: int,
        group: Optional["BindGroup"],
        dynamicOffsets: Union["IntList", List[int]],
    ) -> None:
        if isinstance(dynamicOffsets, list):
            dynamicOffsets_staged = IntList(dynamicOffsets)
        else:
            dynamicOffsets_staged = dynamicOffsets
        return lib.wgpuRenderBundleEncoderSetBindGroup(
            self._cdata,
            groupIndex,
            _ffi_unwrap_optional(group),
            dynamicOffsets_staged._count,
            dynamicOffsets_staged._ptr,
        )

    def setIndexBuffer(
        self, buffer: "Buffer", format: "IndexFormat", offset: int, size: int
    ) -> None:
        return lib.wgpuRenderBundleEncoderSetIndexBuffer(
            self._cdata, buffer._cdata, int(format), offset, size
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuRenderBundleEncoderSetLabel(self._cdata, _ffi_unwrap_str(label))

    def setPipeline(self, pipeline: "RenderPipeline") -> None:
        return lib.wgpuRenderBundleEncoderSetPipeline(self._cdata, pipeline._cdata)

    def setVertexBuffer(
        self, slot: int, buffer: Optional["Buffer"], offset: int, size: int
    ) -> None:
        return lib.wgpuRenderBundleEncoderSetVertexBuffer(
            self._cdata, slot, _ffi_unwrap_optional(buffer), offset, size
        )

    def _reference(self) -> None:
        return lib.wgpuRenderBundleEncoderReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuRenderBundleEncoderRelease(self._cdata)


class RenderPassEncoder:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuRenderPassEncoderRelease)
            if add_ref:
                lib.wgpuRenderPassEncoderReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuRenderPassEncoderRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def beginOcclusionQuery(self, queryIndex: int) -> None:
        return lib.wgpuRenderPassEncoderBeginOcclusionQuery(self._cdata, queryIndex)

    def draw(
        self, vertexCount: int, instanceCount: int, firstVertex: int, firstInstance: int
    ) -> None:
        return lib.wgpuRenderPassEncoderDraw(
            self._cdata, vertexCount, instanceCount, firstVertex, firstInstance
        )

    def drawIndexed(
        self,
        indexCount: int,
        instanceCount: int,
        firstIndex: int,
        baseVertex: int,
        firstInstance: int,
    ) -> None:
        return lib.wgpuRenderPassEncoderDrawIndexed(
            self._cdata, indexCount, instanceCount, firstIndex, baseVertex, firstInstance
        )

    def drawIndexedIndirect(self, indirectBuffer: "Buffer", indirectOffset: int) -> None:
        return lib.wgpuRenderPassEncoderDrawIndexedIndirect(
            self._cdata, indirectBuffer._cdata, indirectOffset
        )

    def drawIndirect(self, indirectBuffer: "Buffer", indirectOffset: int) -> None:
        return lib.wgpuRenderPassEncoderDrawIndirect(
            self._cdata, indirectBuffer._cdata, indirectOffset
        )

    def end(self) -> None:
        ret = lib.wgpuRenderPassEncoderEnd(self._cdata)
        self.release()
        return ret

    def endOcclusionQuery(self) -> None:
        return lib.wgpuRenderPassEncoderEndOcclusionQuery(self._cdata)

    def executeBundles(
        self, bundles: Union["RenderBundleList", List[RenderBundle]]
    ) -> None:
        if isinstance(bundles, list):
            bundles_staged = RenderBundleList(bundles)
        else:
            bundles_staged = bundles
        return lib.wgpuRenderPassEncoderExecuteBundles(
            self._cdata, bundles_staged._count, bundles_staged._ptr
        )

    def insertDebugMarker(self, markerLabel: str) -> None:
        return lib.wgpuRenderPassEncoderInsertDebugMarker(
            self._cdata, _ffi_unwrap_str(markerLabel)
        )

    def popDebugGroup(self) -> None:
        return lib.wgpuRenderPassEncoderPopDebugGroup(self._cdata)

    def pushDebugGroup(self, groupLabel: str) -> None:
        return lib.wgpuRenderPassEncoderPushDebugGroup(
            self._cdata, _ffi_unwrap_str(groupLabel)
        )

    def setBindGroup(
        self,
        groupIndex: int,
        group: Optional["BindGroup"],
        dynamicOffsets: Union["IntList", List[int]],
    ) -> None:
        if isinstance(dynamicOffsets, list):
            dynamicOffsets_staged = IntList(dynamicOffsets)
        else:
            dynamicOffsets_staged = dynamicOffsets
        return lib.wgpuRenderPassEncoderSetBindGroup(
            self._cdata,
            groupIndex,
            _ffi_unwrap_optional(group),
            dynamicOffsets_staged._count,
            dynamicOffsets_staged._ptr,
        )

    def setBlendConstant(self, color: "Color") -> None:
        return lib.wgpuRenderPassEncoderSetBlendConstant(self._cdata, color._cdata)

    def setIndexBuffer(
        self, buffer: "Buffer", format: "IndexFormat", offset: int, size: int
    ) -> None:
        return lib.wgpuRenderPassEncoderSetIndexBuffer(
            self._cdata, buffer._cdata, int(format), offset, size
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuRenderPassEncoderSetLabel(self._cdata, _ffi_unwrap_str(label))

    def setPipeline(self, pipeline: "RenderPipeline") -> None:
        return lib.wgpuRenderPassEncoderSetPipeline(self._cdata, pipeline._cdata)

    def setScissorRect(self, x: int, y: int, width: int, height: int) -> None:
        return lib.wgpuRenderPassEncoderSetScissorRect(self._cdata, x, y, width, height)

    def setStencilReference(self, reference: int) -> None:
        return lib.wgpuRenderPassEncoderSetStencilReference(self._cdata, reference)

    def setVertexBuffer(
        self, slot: int, buffer: Optional["Buffer"], offset: int, size: int
    ) -> None:
        return lib.wgpuRenderPassEncoderSetVertexBuffer(
            self._cdata, slot, _ffi_unwrap_optional(buffer), offset, size
        )

    def setViewport(
        self,
        x: float,
        y: float,
        width: float,
        height: float,
        minDepth: float,
        maxDepth: float,
    ) -> None:
        return lib.wgpuRenderPassEncoderSetViewport(
            self._cdata, x, y, width, height, minDepth, maxDepth
        )

    def _reference(self) -> None:
        return lib.wgpuRenderPassEncoderReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuRenderPassEncoderRelease(self._cdata)

    def setPushConstants(
        self,
        stages: Union["ShaderStageFlags", "ShaderStage", int],
        offset: int,
        sizeBytes: int,
        data: DataPtr,
    ) -> None:
        return lib.wgpuRenderPassEncoderSetPushConstants(
            self._cdata, int(stages), offset, sizeBytes, data._ptr
        )

    def multiDrawIndirect(self, buffer: "Buffer", offset: int, count: int) -> None:
        return lib.wgpuRenderPassEncoderMultiDrawIndirect(
            self._cdata, buffer._cdata, offset, count
        )

    def multiDrawIndexedIndirect(self, buffer: "Buffer", offset: int, count: int) -> None:
        return lib.wgpuRenderPassEncoderMultiDrawIndexedIndirect(
            self._cdata, buffer._cdata, offset, count
        )

    def multiDrawIndirectCount(
        self,
        buffer: "Buffer",
        offset: int,
        count_buffer: "Buffer",
        count_buffer_offset: int,
        max_count: int,
    ) -> None:
        return lib.wgpuRenderPassEncoderMultiDrawIndirectCount(
            self._cdata,
            buffer._cdata,
            offset,
            count_buffer._cdata,
            count_buffer_offset,
            max_count,
        )

    def multiDrawIndexedIndirectCount(
        self,
        buffer: "Buffer",
        offset: int,
        count_buffer: "Buffer",
        count_buffer_offset: int,
        max_count: int,
    ) -> None:
        return lib.wgpuRenderPassEncoderMultiDrawIndexedIndirectCount(
            self._cdata,
            buffer._cdata,
            offset,
            count_buffer._cdata,
            count_buffer_offset,
            max_count,
        )

    def beginPipelineStatisticsQuery(self, querySet: "QuerySet", queryIndex: int) -> None:
        return lib.wgpuRenderPassEncoderBeginPipelineStatisticsQuery(
            self._cdata, querySet._cdata, queryIndex
        )

    def endPipelineStatisticsQuery(self) -> None:
        return lib.wgpuRenderPassEncoderEndPipelineStatisticsQuery(self._cdata)


class RenderPipeline:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuRenderPipelineRelease)
            if add_ref:
                lib.wgpuRenderPipelineReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuRenderPipelineRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def getBindGroupLayout(self, groupIndex: int) -> "BindGroupLayout":
        return BindGroupLayout(
            lib.wgpuRenderPipelineGetBindGroupLayout(self._cdata, groupIndex),
            add_ref=False,
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuRenderPipelineSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuRenderPipelineReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuRenderPipelineRelease(self._cdata)


class Sampler:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuSamplerRelease)
            if add_ref:
                lib.wgpuSamplerReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuSamplerRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuSamplerSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuSamplerReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuSamplerRelease(self._cdata)


class ShaderModule:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuShaderModuleRelease)
            if add_ref:
                lib.wgpuShaderModuleReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuShaderModuleRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def getCompilationInfo(
        self, callback: "ShaderModuleGetCompilationInfoCallback"
    ) -> None:
        return lib.wgpuShaderModuleGetCompilationInfo(
            self._cdata, callback._ptr, callback._userdata
        )

    def setLabel(self, label: str) -> None:
        return lib.wgpuShaderModuleSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuShaderModuleReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuShaderModuleRelease(self._cdata)


class Surface:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuSurfaceRelease)
            if add_ref:
                lib.wgpuSurfaceReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuSurfaceRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def configureFromDesc(self, config: "SurfaceConfiguration") -> None:
        return lib.wgpuSurfaceConfigure(self._cdata, config._cdata)

    def configure(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        device: "Device",
        format: "TextureFormat",
        usage: Union["TextureUsageFlags", "TextureUsage", int],
        viewFormats: Union["TextureFormatList", List["TextureFormat"]],
        alphaMode: "CompositeAlphaMode",
        width: int,
        height: int,
        presentMode: "PresentMode",
    ) -> None:
        return self.configureFromDesc(
            surfaceConfiguration(
                nextInChain=nextInChain,
                device=device,
                format=format,
                usage=usage,
                viewFormats=viewFormats,
                alphaMode=alphaMode,
                width=width,
                height=height,
                presentMode=presentMode,
            )
        )

    def getCapabilities(self, adapter: "Adapter") -> "SurfaceCapabilities":
        # Hand-written because the usage pattern for this is ridiculous
        # (it sets raw pointers onto a struct you provide, and you're
        #  expected to free these arrays with a special function)
        caps = ffi.new("WGPUSurfaceCapabilities *")
        lib.wgpuSurfaceGetCapabilities(self._cdata, adapter._cdata, caps)
        formats = [TextureFormat(caps.formats[idx]) for idx in range(caps.formatCount)]
        present_modes = [
            PresentMode(caps.presentModes[idx]) for idx in range(caps.presentModeCount)
        ]
        alpha_modes = [
            CompositeAlphaMode(caps.alphaModes[idx]) for idx in range(caps.alphaModeCount)
        ]
        # Note! This free function takes the caps struct *by value*, hence
        # the usage of caps[0] to 'dereference' it. Yes this is weird!
        lib.wgpuSurfaceCapabilitiesFreeMembers(caps[0])
        return SurfaceCapabilities(formats, present_modes, alpha_modes)

    def getCurrentTexture(self, surfaceTexture: "SurfaceTexture") -> None:
        return lib.wgpuSurfaceGetCurrentTexture(self._cdata, surfaceTexture._cdata)

    def present(self) -> None:
        return lib.wgpuSurfacePresent(self._cdata)

    def setLabel(self, label: str) -> None:
        return lib.wgpuSurfaceSetLabel(self._cdata, _ffi_unwrap_str(label))

    def unconfigure(self) -> None:
        return lib.wgpuSurfaceUnconfigure(self._cdata)

    def _reference(self) -> None:
        return lib.wgpuSurfaceReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuSurfaceRelease(self._cdata)


class Texture:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuTextureRelease)
            if add_ref:
                lib.wgpuTextureReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuTextureRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def createViewFromDesc(
        self, descriptor: Optional["TextureViewDescriptor"]
    ) -> "TextureView":
        return TextureView(
            lib.wgpuTextureCreateView(self._cdata, _ffi_unwrap_optional(descriptor)),
            add_ref=False,
        )

    def createView(
        self,
        *,
        nextInChain: Optional["ChainedStruct"] = None,
        label: Optional[str] = None,
        format: "TextureFormat",
        dimension: "TextureViewDimension",
        baseMipLevel: int = 0,
        mipLevelCount: int,
        baseArrayLayer: int = 0,
        arrayLayerCount: int,
        aspect: "TextureAspect" = TextureAspect.All,
    ) -> "TextureView":
        return self.createViewFromDesc(
            textureViewDescriptor(
                nextInChain=nextInChain,
                label=label,
                format=format,
                dimension=dimension,
                baseMipLevel=baseMipLevel,
                mipLevelCount=mipLevelCount,
                baseArrayLayer=baseArrayLayer,
                arrayLayerCount=arrayLayerCount,
                aspect=aspect,
            )
        )

    def destroy(self) -> None:
        return lib.wgpuTextureDestroy(self._cdata)

    def getDepthOrArrayLayers(self) -> int:
        return lib.wgpuTextureGetDepthOrArrayLayers(self._cdata)

    def getDimension(self) -> "TextureDimension":
        return TextureDimension(lib.wgpuTextureGetDimension(self._cdata))

    def getFormat(self) -> "TextureFormat":
        return TextureFormat(lib.wgpuTextureGetFormat(self._cdata))

    def getHeight(self) -> int:
        return lib.wgpuTextureGetHeight(self._cdata)

    def getMipLevelCount(self) -> int:
        return lib.wgpuTextureGetMipLevelCount(self._cdata)

    def getSampleCount(self) -> int:
        return lib.wgpuTextureGetSampleCount(self._cdata)

    def getUsage(self) -> "TextureUsageFlags":
        return TextureUsageFlags(lib.wgpuTextureGetUsage(self._cdata))

    def getWidth(self) -> int:
        return lib.wgpuTextureGetWidth(self._cdata)

    def setLabel(self, label: str) -> None:
        return lib.wgpuTextureSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuTextureReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuTextureRelease(self._cdata)


class TextureView:
    def __init__(self, cdata: CData, add_ref: bool = False):
        if cdata != ffi.NULL:
            self._cdata = ffi.gc(cdata, lib.wgpuTextureViewRelease)
            if add_ref:
                lib.wgpuTextureViewReference(self._cdata)
        else:
            self._cdata = ffi.NULL

    def release(self) -> None:
        """Call the underlying wgpu release function;
        works even on leaked objects"""
        if self._cdata == ffi.NULL:
            return
        ffi.gc(self._cdata, None)
        lib.wgpuTextureViewRelease(self._cdata)
        # ffi.release(self._cdata)
        self._cdata = ffi.NULL

    def leak(self) -> None:
        """Prevent the underlying wgpu object from being
        released when this Python object is garbage collected"""
        ffi.gc(self._cdata, None)

    def invalidate(self) -> None:
        """Set this to a null pointer"""
        self._cdata = ffi.NULL

    def isValid(self) -> None:
        return self._cdata != ffi.NULL

    def setLabel(self, label: str) -> None:
        return lib.wgpuTextureViewSetLabel(self._cdata, _ffi_unwrap_str(label))

    def _reference(self) -> None:
        return lib.wgpuTextureViewReference(self._cdata)

    def _release(self) -> None:
        return lib.wgpuTextureViewRelease(self._cdata)


# ChainedStruct is specially defined elsewhere
# ChainedStructOut is specially defined elsewhere


class AdapterInfo:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUAdapterInfo *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStructOut"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStructOut"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def vendor(self) -> str:
        return _ffi_string(self._cdata.vendor)

    @vendor.setter
    def vendor(self, v: str) -> None:
        self._vendor = v
        self._store_vendor = _ffi_unwrap_str(v)
        self._cdata.vendor = self._store_vendor

    @property
    def architecture(self) -> str:
        return _ffi_string(self._cdata.architecture)

    @architecture.setter
    def architecture(self, v: str) -> None:
        self._architecture = v
        self._store_architecture = _ffi_unwrap_str(v)
        self._cdata.architecture = self._store_architecture

    @property
    def device(self) -> str:
        return _ffi_string(self._cdata.device)

    @device.setter
    def device(self, v: str) -> None:
        self._device = v
        self._store_device = _ffi_unwrap_str(v)
        self._cdata.device = self._store_device

    @property
    def description(self) -> str:
        return _ffi_string(self._cdata.description)

    @description.setter
    def description(self, v: str) -> None:
        self._description = v
        self._store_description = _ffi_unwrap_str(v)
        self._cdata.description = self._store_description

    @property
    def backendType(self) -> "BackendType":
        return BackendType(self._cdata.backendType)

    @backendType.setter
    def backendType(self, v: "BackendType") -> None:
        self._cdata.backendType = int(v)

    @property
    def adapterType(self) -> "AdapterType":
        return AdapterType(self._cdata.adapterType)

    @adapterType.setter
    def adapterType(self, v: "AdapterType") -> None:
        self._cdata.adapterType = int(v)

    @property
    def vendorID(self) -> int:
        return self._cdata.vendorID

    @vendorID.setter
    def vendorID(self, v: int) -> None:
        self._cdata.vendorID = v

    @property
    def deviceID(self) -> int:
        return self._cdata.deviceID

    @deviceID.setter
    def deviceID(self, v: int) -> None:
        self._cdata.deviceID = v


def adapterInfo(
    *,
    nextInChain: Optional["ChainedStructOut"] = None,
    vendor: str,
    architecture: str,
    device: str,
    description: str,
    backendType: "BackendType",
    adapterType: "AdapterType",
    vendorID: int,
    deviceID: int,
) -> AdapterInfo:
    ret = AdapterInfo(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.vendor = vendor
    ret.architecture = architecture
    ret.device = device
    ret.description = description
    ret.backendType = backendType
    ret.adapterType = adapterType
    ret.vendorID = vendorID
    ret.deviceID = deviceID
    return ret


class BindGroupEntry:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupEntry *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def binding(self) -> int:
        return self._cdata.binding

    @binding.setter
    def binding(self, v: int) -> None:
        self._cdata.binding = v

    @property
    def buffer(self) -> Optional["Buffer"]:
        return Buffer(self._cdata.buffer, add_ref=True)

    @buffer.setter
    def buffer(self, v: Optional["Buffer"]) -> None:
        self._buffer = v
        if v is None:
            self._cdata.buffer = ffi.NULL
        else:
            self._cdata.buffer = v._cdata

    @property
    def offset(self) -> int:
        return self._cdata.offset

    @offset.setter
    def offset(self, v: int) -> None:
        self._cdata.offset = v

    @property
    def size(self) -> int:
        return self._cdata.size

    @size.setter
    def size(self, v: int) -> None:
        self._cdata.size = v

    @property
    def sampler(self) -> Optional["Sampler"]:
        return Sampler(self._cdata.sampler, add_ref=True)

    @sampler.setter
    def sampler(self, v: Optional["Sampler"]) -> None:
        self._sampler = v
        if v is None:
            self._cdata.sampler = ffi.NULL
        else:
            self._cdata.sampler = v._cdata

    @property
    def textureView(self) -> Optional["TextureView"]:
        return TextureView(self._cdata.textureView, add_ref=True)

    @textureView.setter
    def textureView(self, v: Optional["TextureView"]) -> None:
        self._textureView = v
        if v is None:
            self._cdata.textureView = ffi.NULL
        else:
            self._cdata.textureView = v._cdata


def bindGroupEntry(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    binding: int,
    buffer: Optional["Buffer"] = None,
    offset: int,
    size: int,
    sampler: Optional["Sampler"] = None,
    textureView: Optional["TextureView"] = None,
) -> BindGroupEntry:
    ret = BindGroupEntry(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.binding = binding
    ret.buffer = buffer
    ret.offset = offset
    ret.size = size
    ret.sampler = sampler
    ret.textureView = textureView
    return ret


class BlendComponent:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBlendComponent *", cdata)

    @property
    def operation(self) -> "BlendOperation":
        return BlendOperation(self._cdata.operation)

    @operation.setter
    def operation(self, v: "BlendOperation") -> None:
        self._cdata.operation = int(v)

    @property
    def srcFactor(self) -> "BlendFactor":
        return BlendFactor(self._cdata.srcFactor)

    @srcFactor.setter
    def srcFactor(self, v: "BlendFactor") -> None:
        self._cdata.srcFactor = int(v)

    @property
    def dstFactor(self) -> "BlendFactor":
        return BlendFactor(self._cdata.dstFactor)

    @dstFactor.setter
    def dstFactor(self, v: "BlendFactor") -> None:
        self._cdata.dstFactor = int(v)


def blendComponent(
    *,
    operation: "BlendOperation" = BlendOperation.Add,
    srcFactor: "BlendFactor" = BlendFactor.One,
    dstFactor: "BlendFactor" = BlendFactor.Zero,
) -> BlendComponent:
    ret = BlendComponent(cdata=None, parent=None)
    ret.operation = operation
    ret.srcFactor = srcFactor
    ret.dstFactor = dstFactor
    return ret


class BufferBindingLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBufferBindingLayout *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def type(self) -> "BufferBindingType":
        return BufferBindingType(self._cdata.type)

    @type.setter
    def type(self, v: "BufferBindingType") -> None:
        self._cdata.type = int(v)

    @property
    def hasDynamicOffset(self) -> bool:
        return self._cdata.hasDynamicOffset

    @hasDynamicOffset.setter
    def hasDynamicOffset(self, v: bool) -> None:
        self._cdata.hasDynamicOffset = v

    @property
    def minBindingSize(self) -> int:
        return self._cdata.minBindingSize

    @minBindingSize.setter
    def minBindingSize(self, v: int) -> None:
        self._cdata.minBindingSize = v


def bufferBindingLayout(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    type: "BufferBindingType",
    hasDynamicOffset: bool,
    minBindingSize: int,
) -> BufferBindingLayout:
    ret = BufferBindingLayout(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.type = type
    ret.hasDynamicOffset = hasDynamicOffset
    ret.minBindingSize = minBindingSize
    return ret


class BufferDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBufferDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def usage(self) -> "BufferUsageFlags":
        return BufferUsageFlags(self._cdata.usage)

    @usage.setter
    def usage(self, v: Union["BufferUsageFlags", "BufferUsage", int]) -> None:
        self._cdata.usage = int(v)

    @property
    def size(self) -> int:
        return self._cdata.size

    @size.setter
    def size(self, v: int) -> None:
        self._cdata.size = v

    @property
    def mappedAtCreation(self) -> bool:
        return self._cdata.mappedAtCreation

    @mappedAtCreation.setter
    def mappedAtCreation(self, v: bool) -> None:
        self._cdata.mappedAtCreation = v


def bufferDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    usage: Union["BufferUsageFlags", "BufferUsage", int],
    size: int,
    mappedAtCreation: bool = False,
) -> BufferDescriptor:
    ret = BufferDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.usage = usage
    ret.size = size
    ret.mappedAtCreation = mappedAtCreation
    return ret


class Color:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUColor *", cdata)

    @property
    def r(self) -> float:
        return self._cdata.r

    @r.setter
    def r(self, v: float) -> None:
        self._cdata.r = v

    @property
    def g(self) -> float:
        return self._cdata.g

    @g.setter
    def g(self, v: float) -> None:
        self._cdata.g = v

    @property
    def b(self) -> float:
        return self._cdata.b

    @b.setter
    def b(self, v: float) -> None:
        self._cdata.b = v

    @property
    def a(self) -> float:
        return self._cdata.a

    @a.setter
    def a(self, v: float) -> None:
        self._cdata.a = v


def color(*, r: float, g: float, b: float, a: float) -> Color:
    ret = Color(cdata=None, parent=None)
    ret.r = r
    ret.g = g
    ret.b = b
    ret.a = a
    return ret


class CommandBufferDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUCommandBufferDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label


def commandBufferDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None, label: Optional[str] = None
) -> CommandBufferDescriptor:
    ret = CommandBufferDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    return ret


class CommandEncoderDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUCommandEncoderDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label


def commandEncoderDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None, label: Optional[str] = None
) -> CommandEncoderDescriptor:
    ret = CommandEncoderDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    return ret


class CompilationMessage:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUCompilationMessage *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def message(self) -> Optional[str]:
        return _ffi_string(self._cdata.message)

    @message.setter
    def message(self, v: Optional[str]) -> None:
        self._message = v
        if v is None:
            self._cdata.message = ffi.NULL
        else:
            self._store_message = _ffi_unwrap_str(v)
            self._cdata.message = self._store_message

    @property
    def type(self) -> "CompilationMessageType":
        return CompilationMessageType(self._cdata.type)

    @type.setter
    def type(self, v: "CompilationMessageType") -> None:
        self._cdata.type = int(v)

    @property
    def lineNum(self) -> int:
        return self._cdata.lineNum

    @lineNum.setter
    def lineNum(self, v: int) -> None:
        self._cdata.lineNum = v

    @property
    def linePos(self) -> int:
        return self._cdata.linePos

    @linePos.setter
    def linePos(self, v: int) -> None:
        self._cdata.linePos = v

    @property
    def offset(self) -> int:
        return self._cdata.offset

    @offset.setter
    def offset(self, v: int) -> None:
        self._cdata.offset = v

    @property
    def length(self) -> int:
        return self._cdata.length

    @length.setter
    def length(self, v: int) -> None:
        self._cdata.length = v

    @property
    def utf16LinePos(self) -> int:
        return self._cdata.utf16LinePos

    @utf16LinePos.setter
    def utf16LinePos(self, v: int) -> None:
        self._cdata.utf16LinePos = v

    @property
    def utf16Offset(self) -> int:
        return self._cdata.utf16Offset

    @utf16Offset.setter
    def utf16Offset(self, v: int) -> None:
        self._cdata.utf16Offset = v

    @property
    def utf16Length(self) -> int:
        return self._cdata.utf16Length

    @utf16Length.setter
    def utf16Length(self, v: int) -> None:
        self._cdata.utf16Length = v


def compilationMessage(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    message: Optional[str] = None,
    type: "CompilationMessageType",
    lineNum: int,
    linePos: int,
    offset: int,
    length: int,
    utf16LinePos: int,
    utf16Offset: int,
    utf16Length: int,
) -> CompilationMessage:
    ret = CompilationMessage(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.message = message
    ret.type = type
    ret.lineNum = lineNum
    ret.linePos = linePos
    ret.offset = offset
    ret.length = length
    ret.utf16LinePos = utf16LinePos
    ret.utf16Offset = utf16Offset
    ret.utf16Length = utf16Length
    return ret


class ComputePassTimestampWrites:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUComputePassTimestampWrites *", cdata)

    @property
    def querySet(self) -> "QuerySet":
        return QuerySet(self._cdata.querySet, add_ref=True)

    @querySet.setter
    def querySet(self, v: "QuerySet") -> None:
        self._querySet = v
        self._cdata.querySet = v._cdata

    @property
    def beginningOfPassWriteIndex(self) -> int:
        return self._cdata.beginningOfPassWriteIndex

    @beginningOfPassWriteIndex.setter
    def beginningOfPassWriteIndex(self, v: int) -> None:
        self._cdata.beginningOfPassWriteIndex = v

    @property
    def endOfPassWriteIndex(self) -> int:
        return self._cdata.endOfPassWriteIndex

    @endOfPassWriteIndex.setter
    def endOfPassWriteIndex(self, v: int) -> None:
        self._cdata.endOfPassWriteIndex = v


def computePassTimestampWrites(
    *, querySet: "QuerySet", beginningOfPassWriteIndex: int, endOfPassWriteIndex: int
) -> ComputePassTimestampWrites:
    ret = ComputePassTimestampWrites(cdata=None, parent=None)
    ret.querySet = querySet
    ret.beginningOfPassWriteIndex = beginningOfPassWriteIndex
    ret.endOfPassWriteIndex = endOfPassWriteIndex
    return ret


class ConstantEntry:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUConstantEntry *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def key(self) -> str:
        return _ffi_string(self._cdata.key)

    @key.setter
    def key(self, v: str) -> None:
        self._key = v
        self._store_key = _ffi_unwrap_str(v)
        self._cdata.key = self._store_key

    @property
    def value(self) -> float:
        return self._cdata.value

    @value.setter
    def value(self, v: float) -> None:
        self._cdata.value = v


def constantEntry(
    *, nextInChain: Optional["ChainedStruct"] = None, key: str, value: float
) -> ConstantEntry:
    ret = ConstantEntry(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.key = key
    ret.value = value
    return ret


class Extent3D:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUExtent3D *", cdata)

    @property
    def width(self) -> int:
        return self._cdata.width

    @width.setter
    def width(self, v: int) -> None:
        self._cdata.width = v

    @property
    def height(self) -> int:
        return self._cdata.height

    @height.setter
    def height(self, v: int) -> None:
        self._cdata.height = v

    @property
    def depthOrArrayLayers(self) -> int:
        return self._cdata.depthOrArrayLayers

    @depthOrArrayLayers.setter
    def depthOrArrayLayers(self, v: int) -> None:
        self._cdata.depthOrArrayLayers = v


def extent3D(*, width: int, height: int, depthOrArrayLayers: int) -> Extent3D:
    ret = Extent3D(cdata=None, parent=None)
    ret.width = width
    ret.height = height
    ret.depthOrArrayLayers = depthOrArrayLayers
    return ret


class InstanceDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUInstanceDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata


def instanceDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None
) -> InstanceDescriptor:
    ret = InstanceDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    return ret


class Limits:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPULimits *", cdata)

    @property
    def maxTextureDimension1D(self) -> int:
        return self._cdata.maxTextureDimension1D

    @maxTextureDimension1D.setter
    def maxTextureDimension1D(self, v: int) -> None:
        self._cdata.maxTextureDimension1D = v

    @property
    def maxTextureDimension2D(self) -> int:
        return self._cdata.maxTextureDimension2D

    @maxTextureDimension2D.setter
    def maxTextureDimension2D(self, v: int) -> None:
        self._cdata.maxTextureDimension2D = v

    @property
    def maxTextureDimension3D(self) -> int:
        return self._cdata.maxTextureDimension3D

    @maxTextureDimension3D.setter
    def maxTextureDimension3D(self, v: int) -> None:
        self._cdata.maxTextureDimension3D = v

    @property
    def maxTextureArrayLayers(self) -> int:
        return self._cdata.maxTextureArrayLayers

    @maxTextureArrayLayers.setter
    def maxTextureArrayLayers(self, v: int) -> None:
        self._cdata.maxTextureArrayLayers = v

    @property
    def maxBindGroups(self) -> int:
        return self._cdata.maxBindGroups

    @maxBindGroups.setter
    def maxBindGroups(self, v: int) -> None:
        self._cdata.maxBindGroups = v

    @property
    def maxBindGroupsPlusVertexBuffers(self) -> int:
        return self._cdata.maxBindGroupsPlusVertexBuffers

    @maxBindGroupsPlusVertexBuffers.setter
    def maxBindGroupsPlusVertexBuffers(self, v: int) -> None:
        self._cdata.maxBindGroupsPlusVertexBuffers = v

    @property
    def maxBindingsPerBindGroup(self) -> int:
        return self._cdata.maxBindingsPerBindGroup

    @maxBindingsPerBindGroup.setter
    def maxBindingsPerBindGroup(self, v: int) -> None:
        self._cdata.maxBindingsPerBindGroup = v

    @property
    def maxDynamicUniformBuffersPerPipelineLayout(self) -> int:
        return self._cdata.maxDynamicUniformBuffersPerPipelineLayout

    @maxDynamicUniformBuffersPerPipelineLayout.setter
    def maxDynamicUniformBuffersPerPipelineLayout(self, v: int) -> None:
        self._cdata.maxDynamicUniformBuffersPerPipelineLayout = v

    @property
    def maxDynamicStorageBuffersPerPipelineLayout(self) -> int:
        return self._cdata.maxDynamicStorageBuffersPerPipelineLayout

    @maxDynamicStorageBuffersPerPipelineLayout.setter
    def maxDynamicStorageBuffersPerPipelineLayout(self, v: int) -> None:
        self._cdata.maxDynamicStorageBuffersPerPipelineLayout = v

    @property
    def maxSampledTexturesPerShaderStage(self) -> int:
        return self._cdata.maxSampledTexturesPerShaderStage

    @maxSampledTexturesPerShaderStage.setter
    def maxSampledTexturesPerShaderStage(self, v: int) -> None:
        self._cdata.maxSampledTexturesPerShaderStage = v

    @property
    def maxSamplersPerShaderStage(self) -> int:
        return self._cdata.maxSamplersPerShaderStage

    @maxSamplersPerShaderStage.setter
    def maxSamplersPerShaderStage(self, v: int) -> None:
        self._cdata.maxSamplersPerShaderStage = v

    @property
    def maxStorageBuffersPerShaderStage(self) -> int:
        return self._cdata.maxStorageBuffersPerShaderStage

    @maxStorageBuffersPerShaderStage.setter
    def maxStorageBuffersPerShaderStage(self, v: int) -> None:
        self._cdata.maxStorageBuffersPerShaderStage = v

    @property
    def maxStorageTexturesPerShaderStage(self) -> int:
        return self._cdata.maxStorageTexturesPerShaderStage

    @maxStorageTexturesPerShaderStage.setter
    def maxStorageTexturesPerShaderStage(self, v: int) -> None:
        self._cdata.maxStorageTexturesPerShaderStage = v

    @property
    def maxUniformBuffersPerShaderStage(self) -> int:
        return self._cdata.maxUniformBuffersPerShaderStage

    @maxUniformBuffersPerShaderStage.setter
    def maxUniformBuffersPerShaderStage(self, v: int) -> None:
        self._cdata.maxUniformBuffersPerShaderStage = v

    @property
    def maxUniformBufferBindingSize(self) -> int:
        return self._cdata.maxUniformBufferBindingSize

    @maxUniformBufferBindingSize.setter
    def maxUniformBufferBindingSize(self, v: int) -> None:
        self._cdata.maxUniformBufferBindingSize = v

    @property
    def maxStorageBufferBindingSize(self) -> int:
        return self._cdata.maxStorageBufferBindingSize

    @maxStorageBufferBindingSize.setter
    def maxStorageBufferBindingSize(self, v: int) -> None:
        self._cdata.maxStorageBufferBindingSize = v

    @property
    def minUniformBufferOffsetAlignment(self) -> int:
        return self._cdata.minUniformBufferOffsetAlignment

    @minUniformBufferOffsetAlignment.setter
    def minUniformBufferOffsetAlignment(self, v: int) -> None:
        self._cdata.minUniformBufferOffsetAlignment = v

    @property
    def minStorageBufferOffsetAlignment(self) -> int:
        return self._cdata.minStorageBufferOffsetAlignment

    @minStorageBufferOffsetAlignment.setter
    def minStorageBufferOffsetAlignment(self, v: int) -> None:
        self._cdata.minStorageBufferOffsetAlignment = v

    @property
    def maxVertexBuffers(self) -> int:
        return self._cdata.maxVertexBuffers

    @maxVertexBuffers.setter
    def maxVertexBuffers(self, v: int) -> None:
        self._cdata.maxVertexBuffers = v

    @property
    def maxBufferSize(self) -> int:
        return self._cdata.maxBufferSize

    @maxBufferSize.setter
    def maxBufferSize(self, v: int) -> None:
        self._cdata.maxBufferSize = v

    @property
    def maxVertexAttributes(self) -> int:
        return self._cdata.maxVertexAttributes

    @maxVertexAttributes.setter
    def maxVertexAttributes(self, v: int) -> None:
        self._cdata.maxVertexAttributes = v

    @property
    def maxVertexBufferArrayStride(self) -> int:
        return self._cdata.maxVertexBufferArrayStride

    @maxVertexBufferArrayStride.setter
    def maxVertexBufferArrayStride(self, v: int) -> None:
        self._cdata.maxVertexBufferArrayStride = v

    @property
    def maxInterStageShaderComponents(self) -> int:
        return self._cdata.maxInterStageShaderComponents

    @maxInterStageShaderComponents.setter
    def maxInterStageShaderComponents(self, v: int) -> None:
        self._cdata.maxInterStageShaderComponents = v

    @property
    def maxInterStageShaderVariables(self) -> int:
        return self._cdata.maxInterStageShaderVariables

    @maxInterStageShaderVariables.setter
    def maxInterStageShaderVariables(self, v: int) -> None:
        self._cdata.maxInterStageShaderVariables = v

    @property
    def maxColorAttachments(self) -> int:
        return self._cdata.maxColorAttachments

    @maxColorAttachments.setter
    def maxColorAttachments(self, v: int) -> None:
        self._cdata.maxColorAttachments = v

    @property
    def maxColorAttachmentBytesPerSample(self) -> int:
        return self._cdata.maxColorAttachmentBytesPerSample

    @maxColorAttachmentBytesPerSample.setter
    def maxColorAttachmentBytesPerSample(self, v: int) -> None:
        self._cdata.maxColorAttachmentBytesPerSample = v

    @property
    def maxComputeWorkgroupStorageSize(self) -> int:
        return self._cdata.maxComputeWorkgroupStorageSize

    @maxComputeWorkgroupStorageSize.setter
    def maxComputeWorkgroupStorageSize(self, v: int) -> None:
        self._cdata.maxComputeWorkgroupStorageSize = v

    @property
    def maxComputeInvocationsPerWorkgroup(self) -> int:
        return self._cdata.maxComputeInvocationsPerWorkgroup

    @maxComputeInvocationsPerWorkgroup.setter
    def maxComputeInvocationsPerWorkgroup(self, v: int) -> None:
        self._cdata.maxComputeInvocationsPerWorkgroup = v

    @property
    def maxComputeWorkgroupSizeX(self) -> int:
        return self._cdata.maxComputeWorkgroupSizeX

    @maxComputeWorkgroupSizeX.setter
    def maxComputeWorkgroupSizeX(self, v: int) -> None:
        self._cdata.maxComputeWorkgroupSizeX = v

    @property
    def maxComputeWorkgroupSizeY(self) -> int:
        return self._cdata.maxComputeWorkgroupSizeY

    @maxComputeWorkgroupSizeY.setter
    def maxComputeWorkgroupSizeY(self, v: int) -> None:
        self._cdata.maxComputeWorkgroupSizeY = v

    @property
    def maxComputeWorkgroupSizeZ(self) -> int:
        return self._cdata.maxComputeWorkgroupSizeZ

    @maxComputeWorkgroupSizeZ.setter
    def maxComputeWorkgroupSizeZ(self, v: int) -> None:
        self._cdata.maxComputeWorkgroupSizeZ = v

    @property
    def maxComputeWorkgroupsPerDimension(self) -> int:
        return self._cdata.maxComputeWorkgroupsPerDimension

    @maxComputeWorkgroupsPerDimension.setter
    def maxComputeWorkgroupsPerDimension(self, v: int) -> None:
        self._cdata.maxComputeWorkgroupsPerDimension = v


def limits(
    *,
    maxTextureDimension1D: int,
    maxTextureDimension2D: int,
    maxTextureDimension3D: int,
    maxTextureArrayLayers: int,
    maxBindGroups: int,
    maxBindGroupsPlusVertexBuffers: int,
    maxBindingsPerBindGroup: int,
    maxDynamicUniformBuffersPerPipelineLayout: int,
    maxDynamicStorageBuffersPerPipelineLayout: int,
    maxSampledTexturesPerShaderStage: int,
    maxSamplersPerShaderStage: int,
    maxStorageBuffersPerShaderStage: int,
    maxStorageTexturesPerShaderStage: int,
    maxUniformBuffersPerShaderStage: int,
    maxUniformBufferBindingSize: int,
    maxStorageBufferBindingSize: int,
    minUniformBufferOffsetAlignment: int,
    minStorageBufferOffsetAlignment: int,
    maxVertexBuffers: int,
    maxBufferSize: int,
    maxVertexAttributes: int,
    maxVertexBufferArrayStride: int,
    maxInterStageShaderComponents: int,
    maxInterStageShaderVariables: int,
    maxColorAttachments: int,
    maxColorAttachmentBytesPerSample: int,
    maxComputeWorkgroupStorageSize: int,
    maxComputeInvocationsPerWorkgroup: int,
    maxComputeWorkgroupSizeX: int,
    maxComputeWorkgroupSizeY: int,
    maxComputeWorkgroupSizeZ: int,
    maxComputeWorkgroupsPerDimension: int,
) -> Limits:
    ret = Limits(cdata=None, parent=None)
    ret.maxTextureDimension1D = maxTextureDimension1D
    ret.maxTextureDimension2D = maxTextureDimension2D
    ret.maxTextureDimension3D = maxTextureDimension3D
    ret.maxTextureArrayLayers = maxTextureArrayLayers
    ret.maxBindGroups = maxBindGroups
    ret.maxBindGroupsPlusVertexBuffers = maxBindGroupsPlusVertexBuffers
    ret.maxBindingsPerBindGroup = maxBindingsPerBindGroup
    ret.maxDynamicUniformBuffersPerPipelineLayout = (
        maxDynamicUniformBuffersPerPipelineLayout
    )
    ret.maxDynamicStorageBuffersPerPipelineLayout = (
        maxDynamicStorageBuffersPerPipelineLayout
    )
    ret.maxSampledTexturesPerShaderStage = maxSampledTexturesPerShaderStage
    ret.maxSamplersPerShaderStage = maxSamplersPerShaderStage
    ret.maxStorageBuffersPerShaderStage = maxStorageBuffersPerShaderStage
    ret.maxStorageTexturesPerShaderStage = maxStorageTexturesPerShaderStage
    ret.maxUniformBuffersPerShaderStage = maxUniformBuffersPerShaderStage
    ret.maxUniformBufferBindingSize = maxUniformBufferBindingSize
    ret.maxStorageBufferBindingSize = maxStorageBufferBindingSize
    ret.minUniformBufferOffsetAlignment = minUniformBufferOffsetAlignment
    ret.minStorageBufferOffsetAlignment = minStorageBufferOffsetAlignment
    ret.maxVertexBuffers = maxVertexBuffers
    ret.maxBufferSize = maxBufferSize
    ret.maxVertexAttributes = maxVertexAttributes
    ret.maxVertexBufferArrayStride = maxVertexBufferArrayStride
    ret.maxInterStageShaderComponents = maxInterStageShaderComponents
    ret.maxInterStageShaderVariables = maxInterStageShaderVariables
    ret.maxColorAttachments = maxColorAttachments
    ret.maxColorAttachmentBytesPerSample = maxColorAttachmentBytesPerSample
    ret.maxComputeWorkgroupStorageSize = maxComputeWorkgroupStorageSize
    ret.maxComputeInvocationsPerWorkgroup = maxComputeInvocationsPerWorkgroup
    ret.maxComputeWorkgroupSizeX = maxComputeWorkgroupSizeX
    ret.maxComputeWorkgroupSizeY = maxComputeWorkgroupSizeY
    ret.maxComputeWorkgroupSizeZ = maxComputeWorkgroupSizeZ
    ret.maxComputeWorkgroupsPerDimension = maxComputeWorkgroupsPerDimension
    return ret


class MultisampleState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUMultisampleState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def count(self) -> int:
        return self._cdata.count

    @count.setter
    def count(self, v: int) -> None:
        self._cdata.count = v

    @property
    def mask(self) -> int:
        return self._cdata.mask

    @mask.setter
    def mask(self, v: int) -> None:
        self._cdata.mask = v

    @property
    def alphaToCoverageEnabled(self) -> bool:
        return self._cdata.alphaToCoverageEnabled

    @alphaToCoverageEnabled.setter
    def alphaToCoverageEnabled(self, v: bool) -> None:
        self._cdata.alphaToCoverageEnabled = v


def multisampleState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    count: int = 1,
    mask: int = 0xFFFFFFFF,
    alphaToCoverageEnabled: bool = False,
) -> MultisampleState:
    ret = MultisampleState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.count = count
    ret.mask = mask
    ret.alphaToCoverageEnabled = alphaToCoverageEnabled
    return ret


class Origin3D:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUOrigin3D *", cdata)

    @property
    def x(self) -> int:
        return self._cdata.x

    @x.setter
    def x(self, v: int) -> None:
        self._cdata.x = v

    @property
    def y(self) -> int:
        return self._cdata.y

    @y.setter
    def y(self, v: int) -> None:
        self._cdata.y = v

    @property
    def z(self) -> int:
        return self._cdata.z

    @z.setter
    def z(self, v: int) -> None:
        self._cdata.z = v


def origin3D(*, x: int, y: int, z: int) -> Origin3D:
    ret = Origin3D(cdata=None, parent=None)
    ret.x = x
    ret.y = y
    ret.z = z
    return ret


class PipelineLayoutDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUPipelineLayoutDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def bindGroupLayouts(self) -> "BindGroupLayoutList":
        return self._bindGroupLayouts

    @bindGroupLayouts.setter
    def bindGroupLayouts(
        self, v: Union["BindGroupLayoutList", List["BindGroupLayout"]]
    ) -> None:
        if isinstance(v, list):
            v2 = BindGroupLayoutList(v)
        else:
            v2 = v
        self._bindGroupLayouts = v2
        self._cdata.bindGroupLayoutCount = v2._count
        self._cdata.bindGroupLayouts = v2._ptr


def pipelineLayoutDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    bindGroupLayouts: Union["BindGroupLayoutList", List["BindGroupLayout"]],
) -> PipelineLayoutDescriptor:
    ret = PipelineLayoutDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.bindGroupLayouts = bindGroupLayouts
    return ret


class PrimitiveDepthClipControl(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUPrimitiveDepthClipControl *", cdata)
        self._cdata.chain.sType = SType.PrimitiveDepthClipControl

    @property
    def unclippedDepth(self) -> bool:
        return self._cdata.unclippedDepth

    @unclippedDepth.setter
    def unclippedDepth(self, v: bool) -> None:
        self._cdata.unclippedDepth = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def primitiveDepthClipControl(*, unclippedDepth: bool) -> PrimitiveDepthClipControl:
    ret = PrimitiveDepthClipControl(cdata=None, parent=None)
    ret.unclippedDepth = unclippedDepth
    return ret


class PrimitiveState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUPrimitiveState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def topology(self) -> "PrimitiveTopology":
        return PrimitiveTopology(self._cdata.topology)

    @topology.setter
    def topology(self, v: "PrimitiveTopology") -> None:
        self._cdata.topology = int(v)

    @property
    def stripIndexFormat(self) -> "IndexFormat":
        return IndexFormat(self._cdata.stripIndexFormat)

    @stripIndexFormat.setter
    def stripIndexFormat(self, v: "IndexFormat") -> None:
        self._cdata.stripIndexFormat = int(v)

    @property
    def frontFace(self) -> "FrontFace":
        return FrontFace(self._cdata.frontFace)

    @frontFace.setter
    def frontFace(self, v: "FrontFace") -> None:
        self._cdata.frontFace = int(v)

    @property
    def cullMode(self) -> "CullMode":
        return CullMode(self._cdata.cullMode)

    @cullMode.setter
    def cullMode(self, v: "CullMode") -> None:
        self._cdata.cullMode = int(v)


def primitiveState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    topology: "PrimitiveTopology" = PrimitiveTopology.TriangleList,
    stripIndexFormat: "IndexFormat",
    frontFace: "FrontFace" = FrontFace.CCW,
    cullMode: "CullMode" = CullMode._None,
) -> PrimitiveState:
    ret = PrimitiveState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.topology = topology
    ret.stripIndexFormat = stripIndexFormat
    ret.frontFace = frontFace
    ret.cullMode = cullMode
    return ret


class QuerySetDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUQuerySetDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def type(self) -> "QueryType":
        return QueryType(self._cdata.type)

    @type.setter
    def type(self, v: "QueryType") -> None:
        self._cdata.type = int(v)

    @property
    def count(self) -> int:
        return self._cdata.count

    @count.setter
    def count(self, v: int) -> None:
        self._cdata.count = v


def querySetDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    type: "QueryType",
    count: int,
) -> QuerySetDescriptor:
    ret = QuerySetDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.type = type
    ret.count = count
    return ret


class QueueDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUQueueDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label


def queueDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None, label: Optional[str] = None
) -> QueueDescriptor:
    ret = QueueDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    return ret


class RenderBundleDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderBundleDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label


def renderBundleDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None, label: Optional[str] = None
) -> RenderBundleDescriptor:
    ret = RenderBundleDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    return ret


class RenderBundleEncoderDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderBundleEncoderDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def colorFormats(self) -> "TextureFormatList":
        return self._colorFormats

    @colorFormats.setter
    def colorFormats(self, v: Union["TextureFormatList", List["TextureFormat"]]) -> None:
        if isinstance(v, list):
            v2 = TextureFormatList(v)
        else:
            v2 = v
        self._colorFormats = v2
        self._cdata.colorFormatCount = v2._count
        self._cdata.colorFormats = v2._ptr

    @property
    def depthStencilFormat(self) -> "TextureFormat":
        return TextureFormat(self._cdata.depthStencilFormat)

    @depthStencilFormat.setter
    def depthStencilFormat(self, v: "TextureFormat") -> None:
        self._cdata.depthStencilFormat = int(v)

    @property
    def sampleCount(self) -> int:
        return self._cdata.sampleCount

    @sampleCount.setter
    def sampleCount(self, v: int) -> None:
        self._cdata.sampleCount = v

    @property
    def depthReadOnly(self) -> bool:
        return self._cdata.depthReadOnly

    @depthReadOnly.setter
    def depthReadOnly(self, v: bool) -> None:
        self._cdata.depthReadOnly = v

    @property
    def stencilReadOnly(self) -> bool:
        return self._cdata.stencilReadOnly

    @stencilReadOnly.setter
    def stencilReadOnly(self, v: bool) -> None:
        self._cdata.stencilReadOnly = v


def renderBundleEncoderDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    colorFormats: Union["TextureFormatList", List["TextureFormat"]],
    depthStencilFormat: "TextureFormat",
    sampleCount: int,
    depthReadOnly: bool = False,
    stencilReadOnly: bool = False,
) -> RenderBundleEncoderDescriptor:
    ret = RenderBundleEncoderDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.colorFormats = colorFormats
    ret.depthStencilFormat = depthStencilFormat
    ret.sampleCount = sampleCount
    ret.depthReadOnly = depthReadOnly
    ret.stencilReadOnly = stencilReadOnly
    return ret


class RenderPassDepthStencilAttachment:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPassDepthStencilAttachment *", cdata)

    @property
    def view(self) -> "TextureView":
        return TextureView(self._cdata.view, add_ref=True)

    @view.setter
    def view(self, v: "TextureView") -> None:
        self._view = v
        self._cdata.view = v._cdata

    @property
    def depthLoadOp(self) -> "LoadOp":
        return LoadOp(self._cdata.depthLoadOp)

    @depthLoadOp.setter
    def depthLoadOp(self, v: "LoadOp") -> None:
        self._cdata.depthLoadOp = int(v)

    @property
    def depthStoreOp(self) -> "StoreOp":
        return StoreOp(self._cdata.depthStoreOp)

    @depthStoreOp.setter
    def depthStoreOp(self, v: "StoreOp") -> None:
        self._cdata.depthStoreOp = int(v)

    @property
    def depthClearValue(self) -> float:
        return self._cdata.depthClearValue

    @depthClearValue.setter
    def depthClearValue(self, v: float) -> None:
        self._cdata.depthClearValue = v

    @property
    def depthReadOnly(self) -> bool:
        return self._cdata.depthReadOnly

    @depthReadOnly.setter
    def depthReadOnly(self, v: bool) -> None:
        self._cdata.depthReadOnly = v

    @property
    def stencilLoadOp(self) -> "LoadOp":
        return LoadOp(self._cdata.stencilLoadOp)

    @stencilLoadOp.setter
    def stencilLoadOp(self, v: "LoadOp") -> None:
        self._cdata.stencilLoadOp = int(v)

    @property
    def stencilStoreOp(self) -> "StoreOp":
        return StoreOp(self._cdata.stencilStoreOp)

    @stencilStoreOp.setter
    def stencilStoreOp(self, v: "StoreOp") -> None:
        self._cdata.stencilStoreOp = int(v)

    @property
    def stencilClearValue(self) -> int:
        return self._cdata.stencilClearValue

    @stencilClearValue.setter
    def stencilClearValue(self, v: int) -> None:
        self._cdata.stencilClearValue = v

    @property
    def stencilReadOnly(self) -> bool:
        return self._cdata.stencilReadOnly

    @stencilReadOnly.setter
    def stencilReadOnly(self, v: bool) -> None:
        self._cdata.stencilReadOnly = v


def renderPassDepthStencilAttachment(
    *,
    view: "TextureView",
    depthLoadOp: "LoadOp",
    depthStoreOp: "StoreOp",
    depthClearValue: float,
    depthReadOnly: bool = False,
    stencilLoadOp: "LoadOp",
    stencilStoreOp: "StoreOp",
    stencilClearValue: int = 0,
    stencilReadOnly: bool = False,
) -> RenderPassDepthStencilAttachment:
    ret = RenderPassDepthStencilAttachment(cdata=None, parent=None)
    ret.view = view
    ret.depthLoadOp = depthLoadOp
    ret.depthStoreOp = depthStoreOp
    ret.depthClearValue = depthClearValue
    ret.depthReadOnly = depthReadOnly
    ret.stencilLoadOp = stencilLoadOp
    ret.stencilStoreOp = stencilStoreOp
    ret.stencilClearValue = stencilClearValue
    ret.stencilReadOnly = stencilReadOnly
    return ret


class RenderPassDescriptorMaxDrawCount(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPassDescriptorMaxDrawCount *", cdata)
        self._cdata.chain.sType = SType.RenderPassDescriptorMaxDrawCount

    @property
    def maxDrawCount(self) -> int:
        return self._cdata.maxDrawCount

    @maxDrawCount.setter
    def maxDrawCount(self, v: int) -> None:
        self._cdata.maxDrawCount = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def renderPassDescriptorMaxDrawCount(
    *, maxDrawCount: int
) -> RenderPassDescriptorMaxDrawCount:
    ret = RenderPassDescriptorMaxDrawCount(cdata=None, parent=None)
    ret.maxDrawCount = maxDrawCount
    return ret


class RenderPassTimestampWrites:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPassTimestampWrites *", cdata)

    @property
    def querySet(self) -> "QuerySet":
        return QuerySet(self._cdata.querySet, add_ref=True)

    @querySet.setter
    def querySet(self, v: "QuerySet") -> None:
        self._querySet = v
        self._cdata.querySet = v._cdata

    @property
    def beginningOfPassWriteIndex(self) -> int:
        return self._cdata.beginningOfPassWriteIndex

    @beginningOfPassWriteIndex.setter
    def beginningOfPassWriteIndex(self, v: int) -> None:
        self._cdata.beginningOfPassWriteIndex = v

    @property
    def endOfPassWriteIndex(self) -> int:
        return self._cdata.endOfPassWriteIndex

    @endOfPassWriteIndex.setter
    def endOfPassWriteIndex(self, v: int) -> None:
        self._cdata.endOfPassWriteIndex = v


def renderPassTimestampWrites(
    *, querySet: "QuerySet", beginningOfPassWriteIndex: int, endOfPassWriteIndex: int
) -> RenderPassTimestampWrites:
    ret = RenderPassTimestampWrites(cdata=None, parent=None)
    ret.querySet = querySet
    ret.beginningOfPassWriteIndex = beginningOfPassWriteIndex
    ret.endOfPassWriteIndex = endOfPassWriteIndex
    return ret


class RequestAdapterOptions:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURequestAdapterOptions *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def compatibleSurface(self) -> Optional["Surface"]:
        return Surface(self._cdata.compatibleSurface, add_ref=True)

    @compatibleSurface.setter
    def compatibleSurface(self, v: Optional["Surface"]) -> None:
        self._compatibleSurface = v
        if v is None:
            self._cdata.compatibleSurface = ffi.NULL
        else:
            self._cdata.compatibleSurface = v._cdata

    @property
    def powerPreference(self) -> "PowerPreference":
        return PowerPreference(self._cdata.powerPreference)

    @powerPreference.setter
    def powerPreference(self, v: "PowerPreference") -> None:
        self._cdata.powerPreference = int(v)

    @property
    def backendType(self) -> "BackendType":
        return BackendType(self._cdata.backendType)

    @backendType.setter
    def backendType(self, v: "BackendType") -> None:
        self._cdata.backendType = int(v)

    @property
    def forceFallbackAdapter(self) -> bool:
        return self._cdata.forceFallbackAdapter

    @forceFallbackAdapter.setter
    def forceFallbackAdapter(self, v: bool) -> None:
        self._cdata.forceFallbackAdapter = v


def requestAdapterOptions(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    compatibleSurface: Optional["Surface"] = None,
    powerPreference: "PowerPreference",
    backendType: "BackendType",
    forceFallbackAdapter: bool = False,
) -> RequestAdapterOptions:
    ret = RequestAdapterOptions(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.compatibleSurface = compatibleSurface
    ret.powerPreference = powerPreference
    ret.backendType = backendType
    ret.forceFallbackAdapter = forceFallbackAdapter
    return ret


class SamplerBindingLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSamplerBindingLayout *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def type(self) -> "SamplerBindingType":
        return SamplerBindingType(self._cdata.type)

    @type.setter
    def type(self, v: "SamplerBindingType") -> None:
        self._cdata.type = int(v)


def samplerBindingLayout(
    *, nextInChain: Optional["ChainedStruct"] = None, type: "SamplerBindingType"
) -> SamplerBindingLayout:
    ret = SamplerBindingLayout(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.type = type
    return ret


class SamplerDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSamplerDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def addressModeU(self) -> "AddressMode":
        return AddressMode(self._cdata.addressModeU)

    @addressModeU.setter
    def addressModeU(self, v: "AddressMode") -> None:
        self._cdata.addressModeU = int(v)

    @property
    def addressModeV(self) -> "AddressMode":
        return AddressMode(self._cdata.addressModeV)

    @addressModeV.setter
    def addressModeV(self, v: "AddressMode") -> None:
        self._cdata.addressModeV = int(v)

    @property
    def addressModeW(self) -> "AddressMode":
        return AddressMode(self._cdata.addressModeW)

    @addressModeW.setter
    def addressModeW(self, v: "AddressMode") -> None:
        self._cdata.addressModeW = int(v)

    @property
    def magFilter(self) -> "FilterMode":
        return FilterMode(self._cdata.magFilter)

    @magFilter.setter
    def magFilter(self, v: "FilterMode") -> None:
        self._cdata.magFilter = int(v)

    @property
    def minFilter(self) -> "FilterMode":
        return FilterMode(self._cdata.minFilter)

    @minFilter.setter
    def minFilter(self, v: "FilterMode") -> None:
        self._cdata.minFilter = int(v)

    @property
    def mipmapFilter(self) -> "MipmapFilterMode":
        return MipmapFilterMode(self._cdata.mipmapFilter)

    @mipmapFilter.setter
    def mipmapFilter(self, v: "MipmapFilterMode") -> None:
        self._cdata.mipmapFilter = int(v)

    @property
    def lodMinClamp(self) -> float:
        return self._cdata.lodMinClamp

    @lodMinClamp.setter
    def lodMinClamp(self, v: float) -> None:
        self._cdata.lodMinClamp = v

    @property
    def lodMaxClamp(self) -> float:
        return self._cdata.lodMaxClamp

    @lodMaxClamp.setter
    def lodMaxClamp(self, v: float) -> None:
        self._cdata.lodMaxClamp = v

    @property
    def compare(self) -> "CompareFunction":
        return CompareFunction(self._cdata.compare)

    @compare.setter
    def compare(self, v: "CompareFunction") -> None:
        self._cdata.compare = int(v)

    @property
    def maxAnisotropy(self) -> int:
        return self._cdata.maxAnisotropy

    @maxAnisotropy.setter
    def maxAnisotropy(self, v: int) -> None:
        self._cdata.maxAnisotropy = v


def samplerDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    addressModeU: "AddressMode" = AddressMode.ClampToEdge,
    addressModeV: "AddressMode" = AddressMode.ClampToEdge,
    addressModeW: "AddressMode" = AddressMode.ClampToEdge,
    magFilter: "FilterMode" = FilterMode.Nearest,
    minFilter: "FilterMode" = FilterMode.Nearest,
    mipmapFilter: "MipmapFilterMode" = MipmapFilterMode.Nearest,
    lodMinClamp: float = 0,
    lodMaxClamp: float = 32,
    compare: "CompareFunction",
    maxAnisotropy: int = 1,
) -> SamplerDescriptor:
    ret = SamplerDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.addressModeU = addressModeU
    ret.addressModeV = addressModeV
    ret.addressModeW = addressModeW
    ret.magFilter = magFilter
    ret.minFilter = minFilter
    ret.mipmapFilter = mipmapFilter
    ret.lodMinClamp = lodMinClamp
    ret.lodMaxClamp = lodMaxClamp
    ret.compare = compare
    ret.maxAnisotropy = maxAnisotropy
    return ret


class ShaderModuleCompilationHint:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderModuleCompilationHint *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def entryPoint(self) -> str:
        return _ffi_string(self._cdata.entryPoint)

    @entryPoint.setter
    def entryPoint(self, v: str) -> None:
        self._entryPoint = v
        self._store_entryPoint = _ffi_unwrap_str(v)
        self._cdata.entryPoint = self._store_entryPoint

    @property
    def layout(self) -> "PipelineLayout":
        return PipelineLayout(self._cdata.layout, add_ref=True)

    @layout.setter
    def layout(self, v: "PipelineLayout") -> None:
        self._layout = v
        self._cdata.layout = v._cdata


def shaderModuleCompilationHint(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    entryPoint: str,
    layout: "PipelineLayout",
) -> ShaderModuleCompilationHint:
    ret = ShaderModuleCompilationHint(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.entryPoint = entryPoint
    ret.layout = layout
    return ret


class ShaderModuleSPIRVDescriptor(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderModuleSPIRVDescriptor *", cdata)
        self._cdata.chain.sType = SType.ShaderModuleSPIRVDescriptor

    @property
    def codeSize(self) -> int:
        return self._cdata.codeSize

    @codeSize.setter
    def codeSize(self, v: int) -> None:
        self._cdata.codeSize = v

    @property
    def code(self) -> int:
        return self._code

    @code.setter
    def code(self, v: int) -> None:
        self._code = v
        self._cdata.code = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def shaderModuleSPIRVDescriptor(
    *, codeSize: int, code: int
) -> ShaderModuleSPIRVDescriptor:
    ret = ShaderModuleSPIRVDescriptor(cdata=None, parent=None)
    ret.codeSize = codeSize
    ret.code = code
    return ret


class ShaderModuleWGSLDescriptor(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderModuleWGSLDescriptor *", cdata)
        self._cdata.chain.sType = SType.ShaderModuleWGSLDescriptor

    @property
    def code(self) -> str:
        return _ffi_string(self._cdata.code)

    @code.setter
    def code(self, v: str) -> None:
        self._code = v
        self._store_code = _ffi_unwrap_str(v)
        self._cdata.code = self._store_code

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def shaderModuleWGSLDescriptor(*, code: str) -> ShaderModuleWGSLDescriptor:
    ret = ShaderModuleWGSLDescriptor(cdata=None, parent=None)
    ret.code = code
    return ret


class StencilFaceState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUStencilFaceState *", cdata)

    @property
    def compare(self) -> "CompareFunction":
        return CompareFunction(self._cdata.compare)

    @compare.setter
    def compare(self, v: "CompareFunction") -> None:
        self._cdata.compare = int(v)

    @property
    def failOp(self) -> "StencilOperation":
        return StencilOperation(self._cdata.failOp)

    @failOp.setter
    def failOp(self, v: "StencilOperation") -> None:
        self._cdata.failOp = int(v)

    @property
    def depthFailOp(self) -> "StencilOperation":
        return StencilOperation(self._cdata.depthFailOp)

    @depthFailOp.setter
    def depthFailOp(self, v: "StencilOperation") -> None:
        self._cdata.depthFailOp = int(v)

    @property
    def passOp(self) -> "StencilOperation":
        return StencilOperation(self._cdata.passOp)

    @passOp.setter
    def passOp(self, v: "StencilOperation") -> None:
        self._cdata.passOp = int(v)


def stencilFaceState(
    *,
    compare: "CompareFunction" = CompareFunction.Always,
    failOp: "StencilOperation" = StencilOperation.Keep,
    depthFailOp: "StencilOperation" = StencilOperation.Keep,
    passOp: "StencilOperation" = StencilOperation.Keep,
) -> StencilFaceState:
    ret = StencilFaceState(cdata=None, parent=None)
    ret.compare = compare
    ret.failOp = failOp
    ret.depthFailOp = depthFailOp
    ret.passOp = passOp
    return ret


class StorageTextureBindingLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUStorageTextureBindingLayout *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def access(self) -> "StorageTextureAccess":
        return StorageTextureAccess(self._cdata.access)

    @access.setter
    def access(self, v: "StorageTextureAccess") -> None:
        self._cdata.access = int(v)

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def viewDimension(self) -> "TextureViewDimension":
        return TextureViewDimension(self._cdata.viewDimension)

    @viewDimension.setter
    def viewDimension(self, v: "TextureViewDimension") -> None:
        self._cdata.viewDimension = int(v)


def storageTextureBindingLayout(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    access: "StorageTextureAccess",
    format: "TextureFormat",
    viewDimension: "TextureViewDimension",
) -> StorageTextureBindingLayout:
    ret = StorageTextureBindingLayout(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.access = access
    ret.format = format
    ret.viewDimension = viewDimension
    return ret


class SurfaceCapabilities:
    def __init__(
        self,
        formats: List[TextureFormat],
        presentModes: List[PresentMode],
        alphaModes: List[CompositeAlphaMode],
    ):
        self.formats = formats
        self.presentModes = presentModes
        self.alphaModes = alphaModes


class SurfaceConfiguration:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceConfiguration *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def device(self) -> "Device":
        return Device(self._cdata.device, add_ref=True)

    @device.setter
    def device(self, v: "Device") -> None:
        self._device = v
        self._cdata.device = v._cdata

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def usage(self) -> "TextureUsageFlags":
        return TextureUsageFlags(self._cdata.usage)

    @usage.setter
    def usage(self, v: Union["TextureUsageFlags", "TextureUsage", int]) -> None:
        self._cdata.usage = int(v)

    @property
    def viewFormats(self) -> "TextureFormatList":
        return self._viewFormats

    @viewFormats.setter
    def viewFormats(self, v: Union["TextureFormatList", List["TextureFormat"]]) -> None:
        if isinstance(v, list):
            v2 = TextureFormatList(v)
        else:
            v2 = v
        self._viewFormats = v2
        self._cdata.viewFormatCount = v2._count
        self._cdata.viewFormats = v2._ptr

    @property
    def alphaMode(self) -> "CompositeAlphaMode":
        return CompositeAlphaMode(self._cdata.alphaMode)

    @alphaMode.setter
    def alphaMode(self, v: "CompositeAlphaMode") -> None:
        self._cdata.alphaMode = int(v)

    @property
    def width(self) -> int:
        return self._cdata.width

    @width.setter
    def width(self, v: int) -> None:
        self._cdata.width = v

    @property
    def height(self) -> int:
        return self._cdata.height

    @height.setter
    def height(self, v: int) -> None:
        self._cdata.height = v

    @property
    def presentMode(self) -> "PresentMode":
        return PresentMode(self._cdata.presentMode)

    @presentMode.setter
    def presentMode(self, v: "PresentMode") -> None:
        self._cdata.presentMode = int(v)


def surfaceConfiguration(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    device: "Device",
    format: "TextureFormat",
    usage: Union["TextureUsageFlags", "TextureUsage", int],
    viewFormats: Union["TextureFormatList", List["TextureFormat"]],
    alphaMode: "CompositeAlphaMode",
    width: int,
    height: int,
    presentMode: "PresentMode",
) -> SurfaceConfiguration:
    ret = SurfaceConfiguration(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.device = device
    ret.format = format
    ret.usage = usage
    ret.viewFormats = viewFormats
    ret.alphaMode = alphaMode
    ret.width = width
    ret.height = height
    ret.presentMode = presentMode
    return ret


class SurfaceDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label


def surfaceDescriptor(
    *, nextInChain: Optional["ChainedStruct"] = None, label: Optional[str] = None
) -> SurfaceDescriptor:
    ret = SurfaceDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    return ret


class SurfaceDescriptorFromAndroidNativeWindow(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromAndroidNativeWindow *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromAndroidNativeWindow

    @property
    def window(self) -> VoidPtr:
        return self._window

    @window.setter
    def window(self, v: VoidPtr) -> None:
        self._window = v
        self._cdata.window = v._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromAndroidNativeWindow(
    *, window: VoidPtr
) -> SurfaceDescriptorFromAndroidNativeWindow:
    ret = SurfaceDescriptorFromAndroidNativeWindow(cdata=None, parent=None)
    ret.window = window
    return ret


class SurfaceDescriptorFromCanvasHTMLSelector(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromCanvasHTMLSelector *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromCanvasHTMLSelector

    @property
    def selector(self) -> str:
        return _ffi_string(self._cdata.selector)

    @selector.setter
    def selector(self, v: str) -> None:
        self._selector = v
        self._store_selector = _ffi_unwrap_str(v)
        self._cdata.selector = self._store_selector

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromCanvasHTMLSelector(
    *, selector: str
) -> SurfaceDescriptorFromCanvasHTMLSelector:
    ret = SurfaceDescriptorFromCanvasHTMLSelector(cdata=None, parent=None)
    ret.selector = selector
    return ret


class SurfaceDescriptorFromMetalLayer(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromMetalLayer *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromMetalLayer

    @property
    def layer(self) -> VoidPtr:
        return self._layer

    @layer.setter
    def layer(self, v: VoidPtr) -> None:
        self._layer = v
        self._cdata.layer = v._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromMetalLayer(*, layer: VoidPtr) -> SurfaceDescriptorFromMetalLayer:
    ret = SurfaceDescriptorFromMetalLayer(cdata=None, parent=None)
    ret.layer = layer
    return ret


class SurfaceDescriptorFromWaylandSurface(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromWaylandSurface *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromWaylandSurface

    @property
    def display(self) -> VoidPtr:
        return self._display

    @display.setter
    def display(self, v: VoidPtr) -> None:
        self._display = v
        self._cdata.display = v._ptr

    @property
    def surface(self) -> VoidPtr:
        return self._surface

    @surface.setter
    def surface(self, v: VoidPtr) -> None:
        self._surface = v
        self._cdata.surface = v._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromWaylandSurface(
    *, display: VoidPtr, surface: VoidPtr
) -> SurfaceDescriptorFromWaylandSurface:
    ret = SurfaceDescriptorFromWaylandSurface(cdata=None, parent=None)
    ret.display = display
    ret.surface = surface
    return ret


class SurfaceDescriptorFromWindowsHWND(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromWindowsHWND *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromWindowsHWND

    @property
    def hinstance(self) -> VoidPtr:
        return self._hinstance

    @hinstance.setter
    def hinstance(self, v: VoidPtr) -> None:
        self._hinstance = v
        self._cdata.hinstance = v._ptr

    @property
    def hwnd(self) -> VoidPtr:
        return self._hwnd

    @hwnd.setter
    def hwnd(self, v: VoidPtr) -> None:
        self._hwnd = v
        self._cdata.hwnd = v._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromWindowsHWND(
    *, hinstance: VoidPtr, hwnd: VoidPtr
) -> SurfaceDescriptorFromWindowsHWND:
    ret = SurfaceDescriptorFromWindowsHWND(cdata=None, parent=None)
    ret.hinstance = hinstance
    ret.hwnd = hwnd
    return ret


class SurfaceDescriptorFromXcbWindow(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromXcbWindow *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromXcbWindow

    @property
    def connection(self) -> VoidPtr:
        return self._connection

    @connection.setter
    def connection(self, v: VoidPtr) -> None:
        self._connection = v
        self._cdata.connection = v._ptr

    @property
    def window(self) -> int:
        return self._cdata.window

    @window.setter
    def window(self, v: int) -> None:
        self._cdata.window = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromXcbWindow(
    *, connection: VoidPtr, window: int
) -> SurfaceDescriptorFromXcbWindow:
    ret = SurfaceDescriptorFromXcbWindow(cdata=None, parent=None)
    ret.connection = connection
    ret.window = window
    return ret


class SurfaceDescriptorFromXlibWindow(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceDescriptorFromXlibWindow *", cdata)
        self._cdata.chain.sType = SType.SurfaceDescriptorFromXlibWindow

    @property
    def display(self) -> VoidPtr:
        return self._display

    @display.setter
    def display(self, v: VoidPtr) -> None:
        self._display = v
        self._cdata.display = v._ptr

    @property
    def window(self) -> int:
        return self._cdata.window

    @window.setter
    def window(self, v: int) -> None:
        self._cdata.window = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceDescriptorFromXlibWindow(
    *, display: VoidPtr, window: int
) -> SurfaceDescriptorFromXlibWindow:
    ret = SurfaceDescriptorFromXlibWindow(cdata=None, parent=None)
    ret.display = display
    ret.window = window
    return ret


class SurfaceTexture:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceTexture *", cdata)

    @property
    def texture(self) -> "Texture":
        return Texture(self._cdata.texture, add_ref=True)

    @texture.setter
    def texture(self, v: "Texture") -> None:
        self._texture = v
        self._cdata.texture = v._cdata

    @property
    def suboptimal(self) -> bool:
        return self._cdata.suboptimal

    @suboptimal.setter
    def suboptimal(self, v: bool) -> None:
        self._cdata.suboptimal = v

    @property
    def status(self) -> "SurfaceGetCurrentTextureStatus":
        return SurfaceGetCurrentTextureStatus(self._cdata.status)

    @status.setter
    def status(self, v: "SurfaceGetCurrentTextureStatus") -> None:
        self._cdata.status = int(v)


def surfaceTexture(
    *, texture: "Texture", suboptimal: bool, status: "SurfaceGetCurrentTextureStatus"
) -> SurfaceTexture:
    ret = SurfaceTexture(cdata=None, parent=None)
    ret.texture = texture
    ret.suboptimal = suboptimal
    ret.status = status
    return ret


class TextureBindingLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUTextureBindingLayout *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def sampleType(self) -> "TextureSampleType":
        return TextureSampleType(self._cdata.sampleType)

    @sampleType.setter
    def sampleType(self, v: "TextureSampleType") -> None:
        self._cdata.sampleType = int(v)

    @property
    def viewDimension(self) -> "TextureViewDimension":
        return TextureViewDimension(self._cdata.viewDimension)

    @viewDimension.setter
    def viewDimension(self, v: "TextureViewDimension") -> None:
        self._cdata.viewDimension = int(v)

    @property
    def multisampled(self) -> bool:
        return self._cdata.multisampled

    @multisampled.setter
    def multisampled(self, v: bool) -> None:
        self._cdata.multisampled = v


def textureBindingLayout(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    sampleType: "TextureSampleType",
    viewDimension: "TextureViewDimension",
    multisampled: bool,
) -> TextureBindingLayout:
    ret = TextureBindingLayout(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.sampleType = sampleType
    ret.viewDimension = viewDimension
    ret.multisampled = multisampled
    return ret


class TextureDataLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUTextureDataLayout *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def offset(self) -> int:
        return self._cdata.offset

    @offset.setter
    def offset(self, v: int) -> None:
        self._cdata.offset = v

    @property
    def bytesPerRow(self) -> int:
        return self._cdata.bytesPerRow

    @bytesPerRow.setter
    def bytesPerRow(self, v: int) -> None:
        self._cdata.bytesPerRow = v

    @property
    def rowsPerImage(self) -> int:
        return self._cdata.rowsPerImage

    @rowsPerImage.setter
    def rowsPerImage(self, v: int) -> None:
        self._cdata.rowsPerImage = v


def textureDataLayout(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    offset: int,
    bytesPerRow: int,
    rowsPerImage: int,
) -> TextureDataLayout:
    ret = TextureDataLayout(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.offset = offset
    ret.bytesPerRow = bytesPerRow
    ret.rowsPerImage = rowsPerImage
    return ret


class TextureViewDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUTextureViewDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def dimension(self) -> "TextureViewDimension":
        return TextureViewDimension(self._cdata.dimension)

    @dimension.setter
    def dimension(self, v: "TextureViewDimension") -> None:
        self._cdata.dimension = int(v)

    @property
    def baseMipLevel(self) -> int:
        return self._cdata.baseMipLevel

    @baseMipLevel.setter
    def baseMipLevel(self, v: int) -> None:
        self._cdata.baseMipLevel = v

    @property
    def mipLevelCount(self) -> int:
        return self._cdata.mipLevelCount

    @mipLevelCount.setter
    def mipLevelCount(self, v: int) -> None:
        self._cdata.mipLevelCount = v

    @property
    def baseArrayLayer(self) -> int:
        return self._cdata.baseArrayLayer

    @baseArrayLayer.setter
    def baseArrayLayer(self, v: int) -> None:
        self._cdata.baseArrayLayer = v

    @property
    def arrayLayerCount(self) -> int:
        return self._cdata.arrayLayerCount

    @arrayLayerCount.setter
    def arrayLayerCount(self, v: int) -> None:
        self._cdata.arrayLayerCount = v

    @property
    def aspect(self) -> "TextureAspect":
        return TextureAspect(self._cdata.aspect)

    @aspect.setter
    def aspect(self, v: "TextureAspect") -> None:
        self._cdata.aspect = int(v)


def textureViewDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    format: "TextureFormat",
    dimension: "TextureViewDimension",
    baseMipLevel: int = 0,
    mipLevelCount: int,
    baseArrayLayer: int = 0,
    arrayLayerCount: int,
    aspect: "TextureAspect" = TextureAspect.All,
) -> TextureViewDescriptor:
    ret = TextureViewDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.format = format
    ret.dimension = dimension
    ret.baseMipLevel = baseMipLevel
    ret.mipLevelCount = mipLevelCount
    ret.baseArrayLayer = baseArrayLayer
    ret.arrayLayerCount = arrayLayerCount
    ret.aspect = aspect
    return ret


class UncapturedErrorCallbackInfo:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUUncapturedErrorCallbackInfo *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def callback(self) -> "ErrorCallback":
        return self._callback

    @callback.setter
    def callback(self, v: "ErrorCallback") -> None:
        self._callback = v
        self._cdata.callback = v._ptr
        self._cdata.userdata = v._userdata


def uncapturedErrorCallbackInfo(
    *, nextInChain: Optional["ChainedStruct"] = None, callback: "ErrorCallback"
) -> UncapturedErrorCallbackInfo:
    ret = UncapturedErrorCallbackInfo(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.callback = callback
    return ret


class VertexAttribute:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUVertexAttribute *", cdata)

    @property
    def format(self) -> "VertexFormat":
        return VertexFormat(self._cdata.format)

    @format.setter
    def format(self, v: "VertexFormat") -> None:
        self._cdata.format = int(v)

    @property
    def offset(self) -> int:
        return self._cdata.offset

    @offset.setter
    def offset(self, v: int) -> None:
        self._cdata.offset = v

    @property
    def shaderLocation(self) -> int:
        return self._cdata.shaderLocation

    @shaderLocation.setter
    def shaderLocation(self, v: int) -> None:
        self._cdata.shaderLocation = v


def vertexAttribute(
    *, format: "VertexFormat", offset: int, shaderLocation: int
) -> VertexAttribute:
    ret = VertexAttribute(cdata=None, parent=None)
    ret.format = format
    ret.offset = offset
    ret.shaderLocation = shaderLocation
    return ret


class BindGroupDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def layout(self) -> "BindGroupLayout":
        return BindGroupLayout(self._cdata.layout, add_ref=True)

    @layout.setter
    def layout(self, v: "BindGroupLayout") -> None:
        self._layout = v
        self._cdata.layout = v._cdata

    @property
    def entries(self) -> "BindGroupEntryList":
        return self._entries

    @entries.setter
    def entries(self, v: Union["BindGroupEntryList", List["BindGroupEntry"]]) -> None:
        if isinstance(v, list):
            v2 = BindGroupEntryList(v)
        else:
            v2 = v
        self._entries = v2
        self._cdata.entryCount = v2._count
        self._cdata.entries = v2._ptr


def bindGroupDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    layout: "BindGroupLayout",
    entries: Union["BindGroupEntryList", List["BindGroupEntry"]],
) -> BindGroupDescriptor:
    ret = BindGroupDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.layout = layout
    ret.entries = entries
    return ret


class BindGroupLayoutEntry:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupLayoutEntry *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def binding(self) -> int:
        return self._cdata.binding

    @binding.setter
    def binding(self, v: int) -> None:
        self._cdata.binding = v

    @property
    def visibility(self) -> "ShaderStageFlags":
        return ShaderStageFlags(self._cdata.visibility)

    @visibility.setter
    def visibility(self, v: Union["ShaderStageFlags", "ShaderStage", int]) -> None:
        self._cdata.visibility = int(v)

    @property
    def buffer(self) -> "BufferBindingLayout":
        return BufferBindingLayout(cdata=self._cdata.buffer, parent=self)

    @buffer.setter
    def buffer(self, v: "BufferBindingLayout") -> None:
        self._cdata.buffer = _ffi_deref(v._cdata)

    @property
    def sampler(self) -> "SamplerBindingLayout":
        return SamplerBindingLayout(cdata=self._cdata.sampler, parent=self)

    @sampler.setter
    def sampler(self, v: "SamplerBindingLayout") -> None:
        self._cdata.sampler = _ffi_deref(v._cdata)

    @property
    def texture(self) -> "TextureBindingLayout":
        return TextureBindingLayout(cdata=self._cdata.texture, parent=self)

    @texture.setter
    def texture(self, v: "TextureBindingLayout") -> None:
        self._cdata.texture = _ffi_deref(v._cdata)

    @property
    def storageTexture(self) -> "StorageTextureBindingLayout":
        return StorageTextureBindingLayout(cdata=self._cdata.storageTexture, parent=self)

    @storageTexture.setter
    def storageTexture(self, v: "StorageTextureBindingLayout") -> None:
        self._cdata.storageTexture = _ffi_deref(v._cdata)


def bindGroupLayoutEntry(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    binding: int,
    visibility: Union["ShaderStageFlags", "ShaderStage", int],
    buffer: "BufferBindingLayout",
    sampler: "SamplerBindingLayout",
    texture: "TextureBindingLayout",
    storageTexture: "StorageTextureBindingLayout",
) -> BindGroupLayoutEntry:
    ret = BindGroupLayoutEntry(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.binding = binding
    ret.visibility = visibility
    ret.buffer = buffer
    ret.sampler = sampler
    ret.texture = texture
    ret.storageTexture = storageTexture
    return ret


class BlendState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBlendState *", cdata)

    @property
    def color(self) -> "BlendComponent":
        return BlendComponent(cdata=self._cdata.color, parent=self)

    @color.setter
    def color(self, v: "BlendComponent") -> None:
        self._cdata.color = _ffi_deref(v._cdata)

    @property
    def alpha(self) -> "BlendComponent":
        return BlendComponent(cdata=self._cdata.alpha, parent=self)

    @alpha.setter
    def alpha(self, v: "BlendComponent") -> None:
        self._cdata.alpha = _ffi_deref(v._cdata)


def blendState(*, color: "BlendComponent", alpha: "BlendComponent") -> BlendState:
    ret = BlendState(cdata=None, parent=None)
    ret.color = color
    ret.alpha = alpha
    return ret


class CompilationInfo:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUCompilationInfo *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def messages(self) -> "CompilationMessageList":
        return self._messages

    @messages.setter
    def messages(
        self, v: Union["CompilationMessageList", List["CompilationMessage"]]
    ) -> None:
        if isinstance(v, list):
            v2 = CompilationMessageList(v)
        else:
            v2 = v
        self._messages = v2
        self._cdata.messageCount = v2._count
        self._cdata.messages = v2._ptr


def compilationInfo(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    messages: Union["CompilationMessageList", List["CompilationMessage"]],
) -> CompilationInfo:
    ret = CompilationInfo(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.messages = messages
    return ret


class ComputePassDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUComputePassDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def timestampWrites(self) -> Optional["ComputePassTimestampWrites"]:
        return ComputePassTimestampWrites(cdata=self._cdata.timestampWrites, parent=self)

    @timestampWrites.setter
    def timestampWrites(self, v: Optional["ComputePassTimestampWrites"]) -> None:
        self._timestampWrites = v
        if v is None:
            self._cdata.timestampWrites = ffi.NULL
        else:
            self._cdata.timestampWrites = v._cdata


def computePassDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    timestampWrites: Optional["ComputePassTimestampWrites"] = None,
) -> ComputePassDescriptor:
    ret = ComputePassDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.timestampWrites = timestampWrites
    return ret


class DepthStencilState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUDepthStencilState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def depthWriteEnabled(self) -> bool:
        return self._cdata.depthWriteEnabled

    @depthWriteEnabled.setter
    def depthWriteEnabled(self, v: bool) -> None:
        self._cdata.depthWriteEnabled = v

    @property
    def depthCompare(self) -> "CompareFunction":
        return CompareFunction(self._cdata.depthCompare)

    @depthCompare.setter
    def depthCompare(self, v: "CompareFunction") -> None:
        self._cdata.depthCompare = int(v)

    @property
    def stencilFront(self) -> "StencilFaceState":
        return StencilFaceState(cdata=self._cdata.stencilFront, parent=self)

    @stencilFront.setter
    def stencilFront(self, v: "StencilFaceState") -> None:
        self._cdata.stencilFront = _ffi_deref(v._cdata)

    @property
    def stencilBack(self) -> "StencilFaceState":
        return StencilFaceState(cdata=self._cdata.stencilBack, parent=self)

    @stencilBack.setter
    def stencilBack(self, v: "StencilFaceState") -> None:
        self._cdata.stencilBack = _ffi_deref(v._cdata)

    @property
    def stencilReadMask(self) -> int:
        return self._cdata.stencilReadMask

    @stencilReadMask.setter
    def stencilReadMask(self, v: int) -> None:
        self._cdata.stencilReadMask = v

    @property
    def stencilWriteMask(self) -> int:
        return self._cdata.stencilWriteMask

    @stencilWriteMask.setter
    def stencilWriteMask(self, v: int) -> None:
        self._cdata.stencilWriteMask = v

    @property
    def depthBias(self) -> int:
        return self._cdata.depthBias

    @depthBias.setter
    def depthBias(self, v: int) -> None:
        self._cdata.depthBias = v

    @property
    def depthBiasSlopeScale(self) -> float:
        return self._cdata.depthBiasSlopeScale

    @depthBiasSlopeScale.setter
    def depthBiasSlopeScale(self, v: float) -> None:
        self._cdata.depthBiasSlopeScale = v

    @property
    def depthBiasClamp(self) -> float:
        return self._cdata.depthBiasClamp

    @depthBiasClamp.setter
    def depthBiasClamp(self, v: float) -> None:
        self._cdata.depthBiasClamp = v


def depthStencilState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    format: "TextureFormat",
    depthWriteEnabled: bool,
    depthCompare: "CompareFunction",
    stencilFront: "StencilFaceState",
    stencilBack: "StencilFaceState",
    stencilReadMask: int = 0xFFFFFFFF,
    stencilWriteMask: int = 0xFFFFFFFF,
    depthBias: int = 0,
    depthBiasSlopeScale: float = 0,
    depthBiasClamp: float = 0,
) -> DepthStencilState:
    ret = DepthStencilState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.format = format
    ret.depthWriteEnabled = depthWriteEnabled
    ret.depthCompare = depthCompare
    ret.stencilFront = stencilFront
    ret.stencilBack = stencilBack
    ret.stencilReadMask = stencilReadMask
    ret.stencilWriteMask = stencilWriteMask
    ret.depthBias = depthBias
    ret.depthBiasSlopeScale = depthBiasSlopeScale
    ret.depthBiasClamp = depthBiasClamp
    return ret


class ImageCopyBuffer:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUImageCopyBuffer *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def layout(self) -> "TextureDataLayout":
        return TextureDataLayout(cdata=self._cdata.layout, parent=self)

    @layout.setter
    def layout(self, v: "TextureDataLayout") -> None:
        self._cdata.layout = _ffi_deref(v._cdata)

    @property
    def buffer(self) -> "Buffer":
        return Buffer(self._cdata.buffer, add_ref=True)

    @buffer.setter
    def buffer(self, v: "Buffer") -> None:
        self._buffer = v
        self._cdata.buffer = v._cdata


def imageCopyBuffer(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    layout: "TextureDataLayout",
    buffer: "Buffer",
) -> ImageCopyBuffer:
    ret = ImageCopyBuffer(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.layout = layout
    ret.buffer = buffer
    return ret


class ImageCopyTexture:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUImageCopyTexture *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def texture(self) -> "Texture":
        return Texture(self._cdata.texture, add_ref=True)

    @texture.setter
    def texture(self, v: "Texture") -> None:
        self._texture = v
        self._cdata.texture = v._cdata

    @property
    def mipLevel(self) -> int:
        return self._cdata.mipLevel

    @mipLevel.setter
    def mipLevel(self, v: int) -> None:
        self._cdata.mipLevel = v

    @property
    def origin(self) -> "Origin3D":
        return Origin3D(cdata=self._cdata.origin, parent=self)

    @origin.setter
    def origin(self, v: "Origin3D") -> None:
        self._cdata.origin = _ffi_deref(v._cdata)

    @property
    def aspect(self) -> "TextureAspect":
        return TextureAspect(self._cdata.aspect)

    @aspect.setter
    def aspect(self, v: "TextureAspect") -> None:
        self._cdata.aspect = int(v)


def imageCopyTexture(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    texture: "Texture",
    mipLevel: int,
    origin: "Origin3D",
    aspect: "TextureAspect",
) -> ImageCopyTexture:
    ret = ImageCopyTexture(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.texture = texture
    ret.mipLevel = mipLevel
    ret.origin = origin
    ret.aspect = aspect
    return ret


class ProgrammableStageDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUProgrammableStageDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def module(self) -> "ShaderModule":
        return ShaderModule(self._cdata.module, add_ref=True)

    @module.setter
    def module(self, v: "ShaderModule") -> None:
        self._module = v
        self._cdata.module = v._cdata

    @property
    def entryPoint(self) -> Optional[str]:
        return _ffi_string(self._cdata.entryPoint)

    @entryPoint.setter
    def entryPoint(self, v: Optional[str]) -> None:
        self._entryPoint = v
        if v is None:
            self._cdata.entryPoint = ffi.NULL
        else:
            self._store_entryPoint = _ffi_unwrap_str(v)
            self._cdata.entryPoint = self._store_entryPoint

    @property
    def constants(self) -> "ConstantEntryList":
        return self._constants

    @constants.setter
    def constants(self, v: Union["ConstantEntryList", List["ConstantEntry"]]) -> None:
        if isinstance(v, list):
            v2 = ConstantEntryList(v)
        else:
            v2 = v
        self._constants = v2
        self._cdata.constantCount = v2._count
        self._cdata.constants = v2._ptr


def programmableStageDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    module: "ShaderModule",
    entryPoint: Optional[str] = None,
    constants: Union["ConstantEntryList", List["ConstantEntry"]],
) -> ProgrammableStageDescriptor:
    ret = ProgrammableStageDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.module = module
    ret.entryPoint = entryPoint
    ret.constants = constants
    return ret


class RenderPassColorAttachment:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPassColorAttachment *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def view(self) -> Optional["TextureView"]:
        return TextureView(self._cdata.view, add_ref=True)

    @view.setter
    def view(self, v: Optional["TextureView"]) -> None:
        self._view = v
        if v is None:
            self._cdata.view = ffi.NULL
        else:
            self._cdata.view = v._cdata

    @property
    def depthSlice(self) -> int:
        return self._cdata.depthSlice

    @depthSlice.setter
    def depthSlice(self, v: int) -> None:
        self._cdata.depthSlice = v

    @property
    def resolveTarget(self) -> Optional["TextureView"]:
        return TextureView(self._cdata.resolveTarget, add_ref=True)

    @resolveTarget.setter
    def resolveTarget(self, v: Optional["TextureView"]) -> None:
        self._resolveTarget = v
        if v is None:
            self._cdata.resolveTarget = ffi.NULL
        else:
            self._cdata.resolveTarget = v._cdata

    @property
    def loadOp(self) -> "LoadOp":
        return LoadOp(self._cdata.loadOp)

    @loadOp.setter
    def loadOp(self, v: "LoadOp") -> None:
        self._cdata.loadOp = int(v)

    @property
    def storeOp(self) -> "StoreOp":
        return StoreOp(self._cdata.storeOp)

    @storeOp.setter
    def storeOp(self, v: "StoreOp") -> None:
        self._cdata.storeOp = int(v)

    @property
    def clearValue(self) -> "Color":
        return Color(cdata=self._cdata.clearValue, parent=self)

    @clearValue.setter
    def clearValue(self, v: "Color") -> None:
        self._cdata.clearValue = _ffi_deref(v._cdata)


def renderPassColorAttachment(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    view: Optional["TextureView"] = None,
    depthSlice: int,
    resolveTarget: Optional["TextureView"] = None,
    loadOp: "LoadOp",
    storeOp: "StoreOp",
    clearValue: "Color",
) -> RenderPassColorAttachment:
    ret = RenderPassColorAttachment(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.view = view
    ret.depthSlice = depthSlice
    ret.resolveTarget = resolveTarget
    ret.loadOp = loadOp
    ret.storeOp = storeOp
    ret.clearValue = clearValue
    return ret


class RequiredLimits:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURequiredLimits *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def limits(self) -> "Limits":
        return Limits(cdata=self._cdata.limits, parent=self)

    @limits.setter
    def limits(self, v: "Limits") -> None:
        self._cdata.limits = _ffi_deref(v._cdata)


def requiredLimits(
    *, nextInChain: Optional["ChainedStruct"] = None, limits: "Limits"
) -> RequiredLimits:
    ret = RequiredLimits(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.limits = limits
    return ret


class ShaderModuleDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderModuleDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def hints(self) -> "ShaderModuleCompilationHintList":
        return self._hints

    @hints.setter
    def hints(
        self,
        v: Union["ShaderModuleCompilationHintList", List["ShaderModuleCompilationHint"]],
    ) -> None:
        if isinstance(v, list):
            v2 = ShaderModuleCompilationHintList(v)
        else:
            v2 = v
        self._hints = v2
        self._cdata.hintCount = v2._count
        self._cdata.hints = v2._ptr


def shaderModuleDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    hints: Union["ShaderModuleCompilationHintList", List["ShaderModuleCompilationHint"]],
) -> ShaderModuleDescriptor:
    ret = ShaderModuleDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.hints = hints
    return ret


class SupportedLimits:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSupportedLimits *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStructOut"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStructOut"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def limits(self) -> "Limits":
        return Limits(cdata=self._cdata.limits, parent=self)

    @limits.setter
    def limits(self, v: "Limits") -> None:
        self._cdata.limits = _ffi_deref(v._cdata)


def supportedLimits(
    *, nextInChain: Optional["ChainedStructOut"] = None, limits: "Limits"
) -> SupportedLimits:
    ret = SupportedLimits(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.limits = limits
    return ret


class TextureDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUTextureDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def usage(self) -> "TextureUsageFlags":
        return TextureUsageFlags(self._cdata.usage)

    @usage.setter
    def usage(self, v: Union["TextureUsageFlags", "TextureUsage", int]) -> None:
        self._cdata.usage = int(v)

    @property
    def dimension(self) -> "TextureDimension":
        return TextureDimension(self._cdata.dimension)

    @dimension.setter
    def dimension(self, v: "TextureDimension") -> None:
        self._cdata.dimension = int(v)

    @property
    def size(self) -> "Extent3D":
        return Extent3D(cdata=self._cdata.size, parent=self)

    @size.setter
    def size(self, v: "Extent3D") -> None:
        self._cdata.size = _ffi_deref(v._cdata)

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def mipLevelCount(self) -> int:
        return self._cdata.mipLevelCount

    @mipLevelCount.setter
    def mipLevelCount(self, v: int) -> None:
        self._cdata.mipLevelCount = v

    @property
    def sampleCount(self) -> int:
        return self._cdata.sampleCount

    @sampleCount.setter
    def sampleCount(self, v: int) -> None:
        self._cdata.sampleCount = v

    @property
    def viewFormats(self) -> "TextureFormatList":
        return self._viewFormats

    @viewFormats.setter
    def viewFormats(self, v: Union["TextureFormatList", List["TextureFormat"]]) -> None:
        if isinstance(v, list):
            v2 = TextureFormatList(v)
        else:
            v2 = v
        self._viewFormats = v2
        self._cdata.viewFormatCount = v2._count
        self._cdata.viewFormats = v2._ptr


def textureDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    usage: Union["TextureUsageFlags", "TextureUsage", int],
    dimension: "TextureDimension" = TextureDimension._2D,
    size: "Extent3D",
    format: "TextureFormat",
    mipLevelCount: int = 1,
    sampleCount: int = 1,
    viewFormats: Union["TextureFormatList", List["TextureFormat"]],
) -> TextureDescriptor:
    ret = TextureDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.usage = usage
    ret.dimension = dimension
    ret.size = size
    ret.format = format
    ret.mipLevelCount = mipLevelCount
    ret.sampleCount = sampleCount
    ret.viewFormats = viewFormats
    return ret


class VertexBufferLayout:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUVertexBufferLayout *", cdata)

    @property
    def arrayStride(self) -> int:
        return self._cdata.arrayStride

    @arrayStride.setter
    def arrayStride(self, v: int) -> None:
        self._cdata.arrayStride = v

    @property
    def stepMode(self) -> "VertexStepMode":
        return VertexStepMode(self._cdata.stepMode)

    @stepMode.setter
    def stepMode(self, v: "VertexStepMode") -> None:
        self._cdata.stepMode = int(v)

    @property
    def attributes(self) -> "VertexAttributeList":
        return self._attributes

    @attributes.setter
    def attributes(
        self, v: Union["VertexAttributeList", List["VertexAttribute"]]
    ) -> None:
        if isinstance(v, list):
            v2 = VertexAttributeList(v)
        else:
            v2 = v
        self._attributes = v2
        self._cdata.attributeCount = v2._count
        self._cdata.attributes = v2._ptr


def vertexBufferLayout(
    *,
    arrayStride: int,
    stepMode: "VertexStepMode" = VertexStepMode.Vertex,
    attributes: Union["VertexAttributeList", List["VertexAttribute"]],
) -> VertexBufferLayout:
    ret = VertexBufferLayout(cdata=None, parent=None)
    ret.arrayStride = arrayStride
    ret.stepMode = stepMode
    ret.attributes = attributes
    return ret


class BindGroupLayoutDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupLayoutDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def entries(self) -> "BindGroupLayoutEntryList":
        return self._entries

    @entries.setter
    def entries(
        self, v: Union["BindGroupLayoutEntryList", List["BindGroupLayoutEntry"]]
    ) -> None:
        if isinstance(v, list):
            v2 = BindGroupLayoutEntryList(v)
        else:
            v2 = v
        self._entries = v2
        self._cdata.entryCount = v2._count
        self._cdata.entries = v2._ptr


def bindGroupLayoutDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    entries: Union["BindGroupLayoutEntryList", List["BindGroupLayoutEntry"]],
) -> BindGroupLayoutDescriptor:
    ret = BindGroupLayoutDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.entries = entries
    return ret


class ColorTargetState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUColorTargetState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def format(self) -> "TextureFormat":
        return TextureFormat(self._cdata.format)

    @format.setter
    def format(self, v: "TextureFormat") -> None:
        self._cdata.format = int(v)

    @property
    def blend(self) -> Optional["BlendState"]:
        return BlendState(cdata=self._cdata.blend, parent=self)

    @blend.setter
    def blend(self, v: Optional["BlendState"]) -> None:
        self._blend = v
        if v is None:
            self._cdata.blend = ffi.NULL
        else:
            self._cdata.blend = v._cdata

    @property
    def writeMask(self) -> "ColorWriteMaskFlags":
        return ColorWriteMaskFlags(self._cdata.writeMask)

    @writeMask.setter
    def writeMask(self, v: Union["ColorWriteMaskFlags", "ColorWriteMask", int]) -> None:
        self._cdata.writeMask = int(v)


def colorTargetState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    format: "TextureFormat",
    blend: Optional["BlendState"] = None,
    writeMask: Union["ColorWriteMaskFlags", "ColorWriteMask", int],
) -> ColorTargetState:
    ret = ColorTargetState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.format = format
    ret.blend = blend
    ret.writeMask = writeMask
    return ret


class ComputePipelineDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUComputePipelineDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def layout(self) -> Optional["PipelineLayout"]:
        return PipelineLayout(self._cdata.layout, add_ref=True)

    @layout.setter
    def layout(self, v: Optional["PipelineLayout"]) -> None:
        self._layout = v
        if v is None:
            self._cdata.layout = ffi.NULL
        else:
            self._cdata.layout = v._cdata

    @property
    def compute(self) -> "ProgrammableStageDescriptor":
        return ProgrammableStageDescriptor(cdata=self._cdata.compute, parent=self)

    @compute.setter
    def compute(self, v: "ProgrammableStageDescriptor") -> None:
        self._cdata.compute = _ffi_deref(v._cdata)


def computePipelineDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    layout: Optional["PipelineLayout"] = None,
    compute: "ProgrammableStageDescriptor",
) -> ComputePipelineDescriptor:
    ret = ComputePipelineDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.layout = layout
    ret.compute = compute
    return ret


class DeviceDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUDeviceDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def requiredFeatures(self) -> "FeatureNameList":
        return self._requiredFeatures

    @requiredFeatures.setter
    def requiredFeatures(self, v: Union["FeatureNameList", List["FeatureName"]]) -> None:
        if isinstance(v, list):
            v2 = FeatureNameList(v)
        else:
            v2 = v
        self._requiredFeatures = v2
        self._cdata.requiredFeatureCount = v2._count
        self._cdata.requiredFeatures = v2._ptr

    @property
    def requiredLimits(self) -> Optional["RequiredLimits"]:
        return RequiredLimits(cdata=self._cdata.requiredLimits, parent=self)

    @requiredLimits.setter
    def requiredLimits(self, v: Optional["RequiredLimits"]) -> None:
        self._requiredLimits = v
        if v is None:
            self._cdata.requiredLimits = ffi.NULL
        else:
            self._cdata.requiredLimits = v._cdata

    @property
    def defaultQueue(self) -> "QueueDescriptor":
        return QueueDescriptor(cdata=self._cdata.defaultQueue, parent=self)

    @defaultQueue.setter
    def defaultQueue(self, v: "QueueDescriptor") -> None:
        self._cdata.defaultQueue = _ffi_deref(v._cdata)

    @property
    def deviceLostCallback(self) -> "DeviceLostCallback":
        return self._deviceLostCallback

    @deviceLostCallback.setter
    def deviceLostCallback(self, v: "DeviceLostCallback") -> None:
        self._deviceLostCallback = v
        self._cdata.deviceLostCallback = v._ptr
        self._cdata.deviceLostUserdata = v._userdata

    @property
    def uncapturedErrorCallbackInfo(self) -> "UncapturedErrorCallbackInfo":
        return UncapturedErrorCallbackInfo(
            cdata=self._cdata.uncapturedErrorCallbackInfo, parent=self
        )

    @uncapturedErrorCallbackInfo.setter
    def uncapturedErrorCallbackInfo(self, v: "UncapturedErrorCallbackInfo") -> None:
        self._cdata.uncapturedErrorCallbackInfo = _ffi_deref(v._cdata)


def deviceDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    requiredFeatures: Union["FeatureNameList", List["FeatureName"]],
    requiredLimits: Optional["RequiredLimits"] = None,
    defaultQueue: "QueueDescriptor",
    deviceLostCallback: "DeviceLostCallback",
    uncapturedErrorCallbackInfo: "UncapturedErrorCallbackInfo",
) -> DeviceDescriptor:
    ret = DeviceDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.requiredFeatures = requiredFeatures
    ret.requiredLimits = requiredLimits
    ret.defaultQueue = defaultQueue
    ret.deviceLostCallback = deviceLostCallback
    ret.uncapturedErrorCallbackInfo = uncapturedErrorCallbackInfo
    return ret


class RenderPassDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPassDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def colorAttachments(self) -> "RenderPassColorAttachmentList":
        return self._colorAttachments

    @colorAttachments.setter
    def colorAttachments(
        self, v: Union["RenderPassColorAttachmentList", List["RenderPassColorAttachment"]]
    ) -> None:
        if isinstance(v, list):
            v2 = RenderPassColorAttachmentList(v)
        else:
            v2 = v
        self._colorAttachments = v2
        self._cdata.colorAttachmentCount = v2._count
        self._cdata.colorAttachments = v2._ptr

    @property
    def depthStencilAttachment(self) -> Optional["RenderPassDepthStencilAttachment"]:
        return RenderPassDepthStencilAttachment(
            cdata=self._cdata.depthStencilAttachment, parent=self
        )

    @depthStencilAttachment.setter
    def depthStencilAttachment(
        self, v: Optional["RenderPassDepthStencilAttachment"]
    ) -> None:
        self._depthStencilAttachment = v
        if v is None:
            self._cdata.depthStencilAttachment = ffi.NULL
        else:
            self._cdata.depthStencilAttachment = v._cdata

    @property
    def occlusionQuerySet(self) -> Optional["QuerySet"]:
        return QuerySet(self._cdata.occlusionQuerySet, add_ref=True)

    @occlusionQuerySet.setter
    def occlusionQuerySet(self, v: Optional["QuerySet"]) -> None:
        self._occlusionQuerySet = v
        if v is None:
            self._cdata.occlusionQuerySet = ffi.NULL
        else:
            self._cdata.occlusionQuerySet = v._cdata

    @property
    def timestampWrites(self) -> Optional["RenderPassTimestampWrites"]:
        return RenderPassTimestampWrites(cdata=self._cdata.timestampWrites, parent=self)

    @timestampWrites.setter
    def timestampWrites(self, v: Optional["RenderPassTimestampWrites"]) -> None:
        self._timestampWrites = v
        if v is None:
            self._cdata.timestampWrites = ffi.NULL
        else:
            self._cdata.timestampWrites = v._cdata


def renderPassDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    colorAttachments: Union[
        "RenderPassColorAttachmentList", List["RenderPassColorAttachment"]
    ],
    depthStencilAttachment: Optional["RenderPassDepthStencilAttachment"] = None,
    occlusionQuerySet: Optional["QuerySet"] = None,
    timestampWrites: Optional["RenderPassTimestampWrites"] = None,
) -> RenderPassDescriptor:
    ret = RenderPassDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.colorAttachments = colorAttachments
    ret.depthStencilAttachment = depthStencilAttachment
    ret.occlusionQuerySet = occlusionQuerySet
    ret.timestampWrites = timestampWrites
    return ret


class VertexState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUVertexState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def module(self) -> "ShaderModule":
        return ShaderModule(self._cdata.module, add_ref=True)

    @module.setter
    def module(self, v: "ShaderModule") -> None:
        self._module = v
        self._cdata.module = v._cdata

    @property
    def entryPoint(self) -> Optional[str]:
        return _ffi_string(self._cdata.entryPoint)

    @entryPoint.setter
    def entryPoint(self, v: Optional[str]) -> None:
        self._entryPoint = v
        if v is None:
            self._cdata.entryPoint = ffi.NULL
        else:
            self._store_entryPoint = _ffi_unwrap_str(v)
            self._cdata.entryPoint = self._store_entryPoint

    @property
    def constants(self) -> "ConstantEntryList":
        return self._constants

    @constants.setter
    def constants(self, v: Union["ConstantEntryList", List["ConstantEntry"]]) -> None:
        if isinstance(v, list):
            v2 = ConstantEntryList(v)
        else:
            v2 = v
        self._constants = v2
        self._cdata.constantCount = v2._count
        self._cdata.constants = v2._ptr

    @property
    def buffers(self) -> "VertexBufferLayoutList":
        return self._buffers

    @buffers.setter
    def buffers(
        self, v: Union["VertexBufferLayoutList", List["VertexBufferLayout"]]
    ) -> None:
        if isinstance(v, list):
            v2 = VertexBufferLayoutList(v)
        else:
            v2 = v
        self._buffers = v2
        self._cdata.bufferCount = v2._count
        self._cdata.buffers = v2._ptr


def vertexState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    module: "ShaderModule",
    entryPoint: Optional[str] = None,
    constants: Union["ConstantEntryList", List["ConstantEntry"]],
    buffers: Union["VertexBufferLayoutList", List["VertexBufferLayout"]],
) -> VertexState:
    ret = VertexState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.module = module
    ret.entryPoint = entryPoint
    ret.constants = constants
    ret.buffers = buffers
    return ret


class FragmentState:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUFragmentState *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def module(self) -> "ShaderModule":
        return ShaderModule(self._cdata.module, add_ref=True)

    @module.setter
    def module(self, v: "ShaderModule") -> None:
        self._module = v
        self._cdata.module = v._cdata

    @property
    def entryPoint(self) -> Optional[str]:
        return _ffi_string(self._cdata.entryPoint)

    @entryPoint.setter
    def entryPoint(self, v: Optional[str]) -> None:
        self._entryPoint = v
        if v is None:
            self._cdata.entryPoint = ffi.NULL
        else:
            self._store_entryPoint = _ffi_unwrap_str(v)
            self._cdata.entryPoint = self._store_entryPoint

    @property
    def constants(self) -> "ConstantEntryList":
        return self._constants

    @constants.setter
    def constants(self, v: Union["ConstantEntryList", List["ConstantEntry"]]) -> None:
        if isinstance(v, list):
            v2 = ConstantEntryList(v)
        else:
            v2 = v
        self._constants = v2
        self._cdata.constantCount = v2._count
        self._cdata.constants = v2._ptr

    @property
    def targets(self) -> "ColorTargetStateList":
        return self._targets

    @targets.setter
    def targets(self, v: Union["ColorTargetStateList", List["ColorTargetState"]]) -> None:
        if isinstance(v, list):
            v2 = ColorTargetStateList(v)
        else:
            v2 = v
        self._targets = v2
        self._cdata.targetCount = v2._count
        self._cdata.targets = v2._ptr


def fragmentState(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    module: "ShaderModule",
    entryPoint: Optional[str] = None,
    constants: Union["ConstantEntryList", List["ConstantEntry"]],
    targets: Union["ColorTargetStateList", List["ColorTargetState"]],
) -> FragmentState:
    ret = FragmentState(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.module = module
    ret.entryPoint = entryPoint
    ret.constants = constants
    ret.targets = targets
    return ret


class RenderPipelineDescriptor:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURenderPipelineDescriptor *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def label(self) -> Optional[str]:
        return _ffi_string(self._cdata.label)

    @label.setter
    def label(self, v: Optional[str]) -> None:
        self._label = v
        if v is None:
            self._cdata.label = ffi.NULL
        else:
            self._store_label = _ffi_unwrap_str(v)
            self._cdata.label = self._store_label

    @property
    def layout(self) -> Optional["PipelineLayout"]:
        return PipelineLayout(self._cdata.layout, add_ref=True)

    @layout.setter
    def layout(self, v: Optional["PipelineLayout"]) -> None:
        self._layout = v
        if v is None:
            self._cdata.layout = ffi.NULL
        else:
            self._cdata.layout = v._cdata

    @property
    def vertex(self) -> "VertexState":
        return VertexState(cdata=self._cdata.vertex, parent=self)

    @vertex.setter
    def vertex(self, v: "VertexState") -> None:
        self._cdata.vertex = _ffi_deref(v._cdata)

    @property
    def primitive(self) -> "PrimitiveState":
        return PrimitiveState(cdata=self._cdata.primitive, parent=self)

    @primitive.setter
    def primitive(self, v: "PrimitiveState") -> None:
        self._cdata.primitive = _ffi_deref(v._cdata)

    @property
    def depthStencil(self) -> Optional["DepthStencilState"]:
        return DepthStencilState(cdata=self._cdata.depthStencil, parent=self)

    @depthStencil.setter
    def depthStencil(self, v: Optional["DepthStencilState"]) -> None:
        self._depthStencil = v
        if v is None:
            self._cdata.depthStencil = ffi.NULL
        else:
            self._cdata.depthStencil = v._cdata

    @property
    def multisample(self) -> "MultisampleState":
        return MultisampleState(cdata=self._cdata.multisample, parent=self)

    @multisample.setter
    def multisample(self, v: "MultisampleState") -> None:
        self._cdata.multisample = _ffi_deref(v._cdata)

    @property
    def fragment(self) -> Optional["FragmentState"]:
        return FragmentState(cdata=self._cdata.fragment, parent=self)

    @fragment.setter
    def fragment(self, v: Optional["FragmentState"]) -> None:
        self._fragment = v
        if v is None:
            self._cdata.fragment = ffi.NULL
        else:
            self._cdata.fragment = v._cdata


def renderPipelineDescriptor(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    label: Optional[str] = None,
    layout: Optional["PipelineLayout"] = None,
    vertex: "VertexState",
    primitive: "PrimitiveState",
    depthStencil: Optional["DepthStencilState"] = None,
    multisample: "MultisampleState",
    fragment: Optional["FragmentState"] = None,
) -> RenderPipelineDescriptor:
    ret = RenderPipelineDescriptor(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.label = label
    ret.layout = layout
    ret.vertex = vertex
    ret.primitive = primitive
    ret.depthStencil = depthStencil
    ret.multisample = multisample
    ret.fragment = fragment
    return ret


class InstanceExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUInstanceExtras *", cdata)
        self._cdata.chain.sType = SType.InstanceExtras

    @property
    def backends(self) -> "InstanceBackendFlags":
        return InstanceBackendFlags(self._cdata.backends)

    @backends.setter
    def backends(self, v: Union["InstanceBackendFlags", "InstanceBackend", int]) -> None:
        self._cdata.backends = int(v)

    @property
    def flags(self) -> "InstanceFlags":
        return InstanceFlags(self._cdata.flags)

    @flags.setter
    def flags(self, v: Union["InstanceFlags", "InstanceFlag", int]) -> None:
        self._cdata.flags = int(v)

    @property
    def dx12ShaderCompiler(self) -> "Dx12Compiler":
        return Dx12Compiler(self._cdata.dx12ShaderCompiler)

    @dx12ShaderCompiler.setter
    def dx12ShaderCompiler(self, v: "Dx12Compiler") -> None:
        self._cdata.dx12ShaderCompiler = int(v)

    @property
    def gles3MinorVersion(self) -> "Gles3MinorVersion":
        return Gles3MinorVersion(self._cdata.gles3MinorVersion)

    @gles3MinorVersion.setter
    def gles3MinorVersion(self, v: "Gles3MinorVersion") -> None:
        self._cdata.gles3MinorVersion = int(v)

    @property
    def dxilPath(self) -> str:
        return _ffi_string(self._cdata.dxilPath)

    @dxilPath.setter
    def dxilPath(self, v: str) -> None:
        self._dxilPath = v
        self._store_dxilPath = _ffi_unwrap_str(v)
        self._cdata.dxilPath = self._store_dxilPath

    @property
    def dxcPath(self) -> str:
        return _ffi_string(self._cdata.dxcPath)

    @dxcPath.setter
    def dxcPath(self, v: str) -> None:
        self._dxcPath = v
        self._store_dxcPath = _ffi_unwrap_str(v)
        self._cdata.dxcPath = self._store_dxcPath

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def instanceExtras(
    *,
    backends: Union["InstanceBackendFlags", "InstanceBackend", int],
    flags: Union["InstanceFlags", "InstanceFlag", int],
    dx12ShaderCompiler: "Dx12Compiler",
    gles3MinorVersion: "Gles3MinorVersion",
    dxilPath: str,
    dxcPath: str,
) -> InstanceExtras:
    ret = InstanceExtras(cdata=None, parent=None)
    ret.backends = backends
    ret.flags = flags
    ret.dx12ShaderCompiler = dx12ShaderCompiler
    ret.gles3MinorVersion = gles3MinorVersion
    ret.dxilPath = dxilPath
    ret.dxcPath = dxcPath
    return ret


class DeviceExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUDeviceExtras *", cdata)
        self._cdata.chain.sType = SType.DeviceExtras

    @property
    def tracePath(self) -> str:
        return _ffi_string(self._cdata.tracePath)

    @tracePath.setter
    def tracePath(self, v: str) -> None:
        self._tracePath = v
        self._store_tracePath = _ffi_unwrap_str(v)
        self._cdata.tracePath = self._store_tracePath

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def deviceExtras(*, tracePath: str) -> DeviceExtras:
    ret = DeviceExtras(cdata=None, parent=None)
    ret.tracePath = tracePath
    return ret


class NativeLimits:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUNativeLimits *", cdata)

    @property
    def maxPushConstantSize(self) -> int:
        return self._cdata.maxPushConstantSize

    @maxPushConstantSize.setter
    def maxPushConstantSize(self, v: int) -> None:
        self._cdata.maxPushConstantSize = v

    @property
    def maxNonSamplerBindings(self) -> int:
        return self._cdata.maxNonSamplerBindings

    @maxNonSamplerBindings.setter
    def maxNonSamplerBindings(self, v: int) -> None:
        self._cdata.maxNonSamplerBindings = v


def nativeLimits(*, maxPushConstantSize: int, maxNonSamplerBindings: int) -> NativeLimits:
    ret = NativeLimits(cdata=None, parent=None)
    ret.maxPushConstantSize = maxPushConstantSize
    ret.maxNonSamplerBindings = maxNonSamplerBindings
    return ret


class RequiredLimitsExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURequiredLimitsExtras *", cdata)
        self._cdata.chain.sType = SType.RequiredLimitsExtras

    @property
    def limits(self) -> "NativeLimits":
        return NativeLimits(cdata=self._cdata.limits, parent=self)

    @limits.setter
    def limits(self, v: "NativeLimits") -> None:
        self._cdata.limits = _ffi_deref(v._cdata)

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def requiredLimitsExtras(*, limits: "NativeLimits") -> RequiredLimitsExtras:
    ret = RequiredLimitsExtras(cdata=None, parent=None)
    ret.limits = limits
    return ret


class SupportedLimitsExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSupportedLimitsExtras *", cdata)
        self._cdata.chain.sType = SType.SupportedLimitsExtras

    @property
    def limits(self) -> "NativeLimits":
        return NativeLimits(cdata=self._cdata.limits, parent=self)

    @limits.setter
    def limits(self, v: "NativeLimits") -> None:
        self._cdata.limits = _ffi_deref(v._cdata)

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def supportedLimitsExtras(*, limits: "NativeLimits") -> SupportedLimitsExtras:
    ret = SupportedLimitsExtras(cdata=None, parent=None)
    ret.limits = limits
    return ret


class PushConstantRange:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUPushConstantRange *", cdata)

    @property
    def stages(self) -> "ShaderStageFlags":
        return ShaderStageFlags(self._cdata.stages)

    @stages.setter
    def stages(self, v: Union["ShaderStageFlags", "ShaderStage", int]) -> None:
        self._cdata.stages = int(v)

    @property
    def start(self) -> int:
        return self._cdata.start

    @start.setter
    def start(self, v: int) -> None:
        self._cdata.start = v

    @property
    def end(self) -> int:
        return self._cdata.end

    @end.setter
    def end(self, v: int) -> None:
        self._cdata.end = v


def pushConstantRange(
    *, stages: Union["ShaderStageFlags", "ShaderStage", int], start: int, end: int
) -> PushConstantRange:
    ret = PushConstantRange(cdata=None, parent=None)
    ret.stages = stages
    ret.start = start
    ret.end = end
    return ret


class PipelineLayoutExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUPipelineLayoutExtras *", cdata)
        self._cdata.chain.sType = SType.PipelineLayoutExtras

    @property
    def pushConstantRanges(self) -> "PushConstantRangeList":
        return self._pushConstantRanges

    @pushConstantRanges.setter
    def pushConstantRanges(
        self, v: Union["PushConstantRangeList", List["PushConstantRange"]]
    ) -> None:
        if isinstance(v, list):
            v2 = PushConstantRangeList(v)
        else:
            v2 = v
        self._pushConstantRanges = v2
        self._cdata.pushConstantRangeCount = v2._count
        self._cdata.pushConstantRanges = v2._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def pipelineLayoutExtras(
    *, pushConstantRanges: Union["PushConstantRangeList", List["PushConstantRange"]]
) -> PipelineLayoutExtras:
    ret = PipelineLayoutExtras(cdata=None, parent=None)
    ret.pushConstantRanges = pushConstantRanges
    return ret


class WrappedSubmissionIndex:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUWrappedSubmissionIndex *", cdata)

    @property
    def queue(self) -> "Queue":
        return Queue(self._cdata.queue, add_ref=True)

    @queue.setter
    def queue(self, v: "Queue") -> None:
        self._queue = v
        self._cdata.queue = v._cdata

    @property
    def submissionIndex(self) -> int:
        return self._cdata.submissionIndex

    @submissionIndex.setter
    def submissionIndex(self, v: int) -> None:
        self._cdata.submissionIndex = v


def wrappedSubmissionIndex(
    *, queue: "Queue", submissionIndex: int
) -> WrappedSubmissionIndex:
    ret = WrappedSubmissionIndex(cdata=None, parent=None)
    ret.queue = queue
    ret.submissionIndex = submissionIndex
    return ret


class ShaderDefine:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderDefine *", cdata)

    @property
    def name(self) -> str:
        return _ffi_string(self._cdata.name)

    @name.setter
    def name(self, v: str) -> None:
        self._name = v
        self._store_name = _ffi_unwrap_str(v)
        self._cdata.name = self._store_name

    @property
    def value(self) -> str:
        return _ffi_string(self._cdata.value)

    @value.setter
    def value(self, v: str) -> None:
        self._value = v
        self._store_value = _ffi_unwrap_str(v)
        self._cdata.value = self._store_value


def shaderDefine(*, name: str, value: str) -> ShaderDefine:
    ret = ShaderDefine(cdata=None, parent=None)
    ret.name = name
    ret.value = value
    return ret


class ShaderModuleGLSLDescriptor(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUShaderModuleGLSLDescriptor *", cdata)
        self._cdata.chain.sType = SType.ShaderModuleGLSLDescriptor

    @property
    def stage(self) -> "ShaderStage":
        return ShaderStage(self._cdata.stage)

    @stage.setter
    def stage(self, v: "ShaderStage") -> None:
        self._cdata.stage = int(v)

    @property
    def code(self) -> str:
        return _ffi_string(self._cdata.code)

    @code.setter
    def code(self, v: str) -> None:
        self._code = v
        self._store_code = _ffi_unwrap_str(v)
        self._cdata.code = self._store_code

    @property
    def defineCount(self) -> int:
        return self._cdata.defineCount

    @defineCount.setter
    def defineCount(self, v: int) -> None:
        self._cdata.defineCount = v

    @property
    def defines(self) -> "ShaderDefine":
        return ShaderDefine(cdata=self._cdata.defines, parent=self)

    @defines.setter
    def defines(self, v: "ShaderDefine") -> None:
        self._defines = v
        self._cdata.defines = v._cdata

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def shaderModuleGLSLDescriptor(
    *, stage: "ShaderStage", code: str, defineCount: int, defines: "ShaderDefine"
) -> ShaderModuleGLSLDescriptor:
    ret = ShaderModuleGLSLDescriptor(cdata=None, parent=None)
    ret.stage = stage
    ret.code = code
    ret.defineCount = defineCount
    ret.defines = defines
    return ret


class RegistryReport:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPURegistryReport *", cdata)

    @property
    def numAllocated(self) -> int:
        return self._cdata.numAllocated

    @numAllocated.setter
    def numAllocated(self, v: int) -> None:
        self._cdata.numAllocated = v

    @property
    def numKeptFromUser(self) -> int:
        return self._cdata.numKeptFromUser

    @numKeptFromUser.setter
    def numKeptFromUser(self, v: int) -> None:
        self._cdata.numKeptFromUser = v

    @property
    def numReleasedFromUser(self) -> int:
        return self._cdata.numReleasedFromUser

    @numReleasedFromUser.setter
    def numReleasedFromUser(self, v: int) -> None:
        self._cdata.numReleasedFromUser = v

    @property
    def numError(self) -> int:
        return self._cdata.numError

    @numError.setter
    def numError(self, v: int) -> None:
        self._cdata.numError = v

    @property
    def elementSize(self) -> int:
        return self._cdata.elementSize

    @elementSize.setter
    def elementSize(self, v: int) -> None:
        self._cdata.elementSize = v


def registryReport(
    *,
    numAllocated: int,
    numKeptFromUser: int,
    numReleasedFromUser: int,
    numError: int,
    elementSize: int,
) -> RegistryReport:
    ret = RegistryReport(cdata=None, parent=None)
    ret.numAllocated = numAllocated
    ret.numKeptFromUser = numKeptFromUser
    ret.numReleasedFromUser = numReleasedFromUser
    ret.numError = numError
    ret.elementSize = elementSize
    return ret


class HubReport:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUHubReport *", cdata)

    @property
    def adapters(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.adapters, parent=self)

    @adapters.setter
    def adapters(self, v: "RegistryReport") -> None:
        self._cdata.adapters = _ffi_deref(v._cdata)

    @property
    def devices(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.devices, parent=self)

    @devices.setter
    def devices(self, v: "RegistryReport") -> None:
        self._cdata.devices = _ffi_deref(v._cdata)

    @property
    def queues(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.queues, parent=self)

    @queues.setter
    def queues(self, v: "RegistryReport") -> None:
        self._cdata.queues = _ffi_deref(v._cdata)

    @property
    def pipelineLayouts(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.pipelineLayouts, parent=self)

    @pipelineLayouts.setter
    def pipelineLayouts(self, v: "RegistryReport") -> None:
        self._cdata.pipelineLayouts = _ffi_deref(v._cdata)

    @property
    def shaderModules(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.shaderModules, parent=self)

    @shaderModules.setter
    def shaderModules(self, v: "RegistryReport") -> None:
        self._cdata.shaderModules = _ffi_deref(v._cdata)

    @property
    def bindGroupLayouts(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.bindGroupLayouts, parent=self)

    @bindGroupLayouts.setter
    def bindGroupLayouts(self, v: "RegistryReport") -> None:
        self._cdata.bindGroupLayouts = _ffi_deref(v._cdata)

    @property
    def bindGroups(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.bindGroups, parent=self)

    @bindGroups.setter
    def bindGroups(self, v: "RegistryReport") -> None:
        self._cdata.bindGroups = _ffi_deref(v._cdata)

    @property
    def commandBuffers(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.commandBuffers, parent=self)

    @commandBuffers.setter
    def commandBuffers(self, v: "RegistryReport") -> None:
        self._cdata.commandBuffers = _ffi_deref(v._cdata)

    @property
    def renderBundles(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.renderBundles, parent=self)

    @renderBundles.setter
    def renderBundles(self, v: "RegistryReport") -> None:
        self._cdata.renderBundles = _ffi_deref(v._cdata)

    @property
    def renderPipelines(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.renderPipelines, parent=self)

    @renderPipelines.setter
    def renderPipelines(self, v: "RegistryReport") -> None:
        self._cdata.renderPipelines = _ffi_deref(v._cdata)

    @property
    def computePipelines(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.computePipelines, parent=self)

    @computePipelines.setter
    def computePipelines(self, v: "RegistryReport") -> None:
        self._cdata.computePipelines = _ffi_deref(v._cdata)

    @property
    def querySets(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.querySets, parent=self)

    @querySets.setter
    def querySets(self, v: "RegistryReport") -> None:
        self._cdata.querySets = _ffi_deref(v._cdata)

    @property
    def buffers(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.buffers, parent=self)

    @buffers.setter
    def buffers(self, v: "RegistryReport") -> None:
        self._cdata.buffers = _ffi_deref(v._cdata)

    @property
    def textures(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.textures, parent=self)

    @textures.setter
    def textures(self, v: "RegistryReport") -> None:
        self._cdata.textures = _ffi_deref(v._cdata)

    @property
    def textureViews(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.textureViews, parent=self)

    @textureViews.setter
    def textureViews(self, v: "RegistryReport") -> None:
        self._cdata.textureViews = _ffi_deref(v._cdata)

    @property
    def samplers(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.samplers, parent=self)

    @samplers.setter
    def samplers(self, v: "RegistryReport") -> None:
        self._cdata.samplers = _ffi_deref(v._cdata)


def hubReport(
    *,
    adapters: "RegistryReport",
    devices: "RegistryReport",
    queues: "RegistryReport",
    pipelineLayouts: "RegistryReport",
    shaderModules: "RegistryReport",
    bindGroupLayouts: "RegistryReport",
    bindGroups: "RegistryReport",
    commandBuffers: "RegistryReport",
    renderBundles: "RegistryReport",
    renderPipelines: "RegistryReport",
    computePipelines: "RegistryReport",
    querySets: "RegistryReport",
    buffers: "RegistryReport",
    textures: "RegistryReport",
    textureViews: "RegistryReport",
    samplers: "RegistryReport",
) -> HubReport:
    ret = HubReport(cdata=None, parent=None)
    ret.adapters = adapters
    ret.devices = devices
    ret.queues = queues
    ret.pipelineLayouts = pipelineLayouts
    ret.shaderModules = shaderModules
    ret.bindGroupLayouts = bindGroupLayouts
    ret.bindGroups = bindGroups
    ret.commandBuffers = commandBuffers
    ret.renderBundles = renderBundles
    ret.renderPipelines = renderPipelines
    ret.computePipelines = computePipelines
    ret.querySets = querySets
    ret.buffers = buffers
    ret.textures = textures
    ret.textureViews = textureViews
    ret.samplers = samplers
    return ret


class GlobalReport:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUGlobalReport *", cdata)

    @property
    def surfaces(self) -> "RegistryReport":
        return RegistryReport(cdata=self._cdata.surfaces, parent=self)

    @surfaces.setter
    def surfaces(self, v: "RegistryReport") -> None:
        self._cdata.surfaces = _ffi_deref(v._cdata)

    @property
    def backendType(self) -> "BackendType":
        return BackendType(self._cdata.backendType)

    @backendType.setter
    def backendType(self, v: "BackendType") -> None:
        self._cdata.backendType = int(v)

    @property
    def vulkan(self) -> "HubReport":
        return HubReport(cdata=self._cdata.vulkan, parent=self)

    @vulkan.setter
    def vulkan(self, v: "HubReport") -> None:
        self._cdata.vulkan = _ffi_deref(v._cdata)

    @property
    def metal(self) -> "HubReport":
        return HubReport(cdata=self._cdata.metal, parent=self)

    @metal.setter
    def metal(self, v: "HubReport") -> None:
        self._cdata.metal = _ffi_deref(v._cdata)

    @property
    def dx12(self) -> "HubReport":
        return HubReport(cdata=self._cdata.dx12, parent=self)

    @dx12.setter
    def dx12(self, v: "HubReport") -> None:
        self._cdata.dx12 = _ffi_deref(v._cdata)

    @property
    def gl(self) -> "HubReport":
        return HubReport(cdata=self._cdata.gl, parent=self)

    @gl.setter
    def gl(self, v: "HubReport") -> None:
        self._cdata.gl = _ffi_deref(v._cdata)


def globalReport(
    *,
    surfaces: "RegistryReport",
    backendType: "BackendType",
    vulkan: "HubReport",
    metal: "HubReport",
    dx12: "HubReport",
    gl: "HubReport",
) -> GlobalReport:
    ret = GlobalReport(cdata=None, parent=None)
    ret.surfaces = surfaces
    ret.backendType = backendType
    ret.vulkan = vulkan
    ret.metal = metal
    ret.dx12 = dx12
    ret.gl = gl
    return ret


class InstanceEnumerateAdapterOptions:
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUInstanceEnumerateAdapterOptions *", cdata)

    @property
    def nextInChain(self) -> Optional["ChainedStruct"]:
        return self._nextInChain

    @nextInChain.setter
    def nextInChain(self, v: Optional["ChainedStruct"]) -> None:
        self._nextInChain = v
        if v is None:
            self._cdata.nextInChain = ffi.NULL
        else:
            self._cdata.nextInChain = v._cdata

    @property
    def backends(self) -> "InstanceBackendFlags":
        return InstanceBackendFlags(self._cdata.backends)

    @backends.setter
    def backends(self, v: Union["InstanceBackendFlags", "InstanceBackend", int]) -> None:
        self._cdata.backends = int(v)


def instanceEnumerateAdapterOptions(
    *,
    nextInChain: Optional["ChainedStruct"] = None,
    backends: Union["InstanceBackendFlags", "InstanceBackend", int],
) -> InstanceEnumerateAdapterOptions:
    ret = InstanceEnumerateAdapterOptions(cdata=None, parent=None)
    ret.nextInChain = nextInChain
    ret.backends = backends
    return ret


class BindGroupEntryExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupEntryExtras *", cdata)
        self._cdata.chain.sType = SType.BindGroupEntryExtras

    @property
    def buffers(self) -> "BufferList":
        return self._buffers

    @buffers.setter
    def buffers(self, v: Union["BufferList", List["Buffer"]]) -> None:
        if isinstance(v, list):
            v2 = BufferList(v)
        else:
            v2 = v
        self._buffers = v2
        self._cdata.bufferCount = v2._count
        self._cdata.buffers = v2._ptr

    @property
    def samplers(self) -> "SamplerList":
        return self._samplers

    @samplers.setter
    def samplers(self, v: Union["SamplerList", List["Sampler"]]) -> None:
        if isinstance(v, list):
            v2 = SamplerList(v)
        else:
            v2 = v
        self._samplers = v2
        self._cdata.samplerCount = v2._count
        self._cdata.samplers = v2._ptr

    @property
    def textureViews(self) -> "TextureViewList":
        return self._textureViews

    @textureViews.setter
    def textureViews(self, v: Union["TextureViewList", List["TextureView"]]) -> None:
        if isinstance(v, list):
            v2 = TextureViewList(v)
        else:
            v2 = v
        self._textureViews = v2
        self._cdata.textureViewCount = v2._count
        self._cdata.textureViews = v2._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def bindGroupEntryExtras(
    *,
    buffers: Union["BufferList", List["Buffer"]],
    samplers: Union["SamplerList", List["Sampler"]],
    textureViews: Union["TextureViewList", List["TextureView"]],
) -> BindGroupEntryExtras:
    ret = BindGroupEntryExtras(cdata=None, parent=None)
    ret.buffers = buffers
    ret.samplers = samplers
    ret.textureViews = textureViews
    return ret


class BindGroupLayoutEntryExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUBindGroupLayoutEntryExtras *", cdata)
        self._cdata.chain.sType = SType.BindGroupLayoutEntryExtras

    @property
    def count(self) -> int:
        return self._cdata.count

    @count.setter
    def count(self, v: int) -> None:
        self._cdata.count = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def bindGroupLayoutEntryExtras(*, count: int) -> BindGroupLayoutEntryExtras:
    ret = BindGroupLayoutEntryExtras(cdata=None, parent=None)
    ret.count = count
    return ret


class QuerySetDescriptorExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUQuerySetDescriptorExtras *", cdata)
        self._cdata.chain.sType = SType.QuerySetDescriptorExtras

    @property
    def pipelineStatistics(self) -> "PipelineStatisticNameList":
        return self._pipelineStatistics

    @pipelineStatistics.setter
    def pipelineStatistics(
        self, v: Union["PipelineStatisticNameList", List["PipelineStatisticName"]]
    ) -> None:
        if isinstance(v, list):
            v2 = PipelineStatisticNameList(v)
        else:
            v2 = v
        self._pipelineStatistics = v2
        self._cdata.pipelineStatisticCount = v2._count
        self._cdata.pipelineStatistics = v2._ptr

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def querySetDescriptorExtras(
    *,
    pipelineStatistics: Union["PipelineStatisticNameList", List["PipelineStatisticName"]],
) -> QuerySetDescriptorExtras:
    ret = QuerySetDescriptorExtras(cdata=None, parent=None)
    ret.pipelineStatistics = pipelineStatistics
    return ret


class SurfaceConfigurationExtras(Chainable):
    def __init__(self, *, cdata: Optional[CData] = None, parent: Optional[Any] = None):
        self._parent = parent
        self._cdata = _ffi_init("WGPUSurfaceConfigurationExtras *", cdata)
        self._cdata.chain.sType = SType.SurfaceConfigurationExtras

    @property
    def desiredMaximumFrameLatency(self) -> int:
        return self._cdata.desiredMaximumFrameLatency

    @desiredMaximumFrameLatency.setter
    def desiredMaximumFrameLatency(self, v: int) -> None:
        self._cdata.desiredMaximumFrameLatency = v

    @property
    def _chain(self) -> Any:
        return self._cdata.chain


def surfaceConfigurationExtras(
    *, desiredMaximumFrameLatency: int
) -> SurfaceConfigurationExtras:
    ret = SurfaceConfigurationExtras(cdata=None, parent=None)
    ret.desiredMaximumFrameLatency = desiredMaximumFrameLatency
    return ret


# Loose functions
def createInstanceFromDesc(descriptor: Optional["InstanceDescriptor"]) -> "Instance":
    return Instance(
        lib.wgpuCreateInstance(_ffi_unwrap_optional(descriptor)), add_ref=False
    )


def createInstance(*, nextInChain: Optional["ChainedStruct"] = None) -> "Instance":
    return createInstanceFromDesc(instanceDescriptor(nextInChain=nextInChain))


def adapterInfoFreeMembers(adapterInfo: "AdapterInfo") -> None:
    return lib.wgpuAdapterInfoFreeMembers(_ffi_deref(adapterInfo._cdata))


# FreeMembers: Not needed
# def FreeMembers(...):


def setLogCallback(callback: "LogCallback") -> None:
    return lib.wgpuSetLogCallback(callback._ptr, callback._userdata)


def setLogLevel(level: "LogLevel") -> None:
    return lib.wgpuSetLogLevel(int(level))


def getVersion() -> int:
    return lib.wgpuGetVersion()


# Util wrapper types

_callback_map_DeviceLostCallback = CBMap()


@ffi.def_extern()
def _raw_callback_DeviceLostCallback(reason, message, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_DeviceLostCallback.get(idx)
    if cb is not None:
        cb(DeviceLostReason(reason), _ffi_string(message))


class DeviceLostCallback:
    def __init__(self, callback: Callable[["DeviceLostReason", str], None]):
        self.index = _callback_map_DeviceLostCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_DeviceLostCallback

    def remove(self) -> None:
        _callback_map_DeviceLostCallback.remove(self.index)


_callback_map_ErrorCallback = CBMap()


@ffi.def_extern()
def _raw_callback_ErrorCallback(type, message, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_ErrorCallback.get(idx)
    if cb is not None:
        cb(ErrorType(type), _ffi_string(message))


class ErrorCallback:
    def __init__(self, callback: Callable[["ErrorType", str], None]):
        self.index = _callback_map_ErrorCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_ErrorCallback

    def remove(self) -> None:
        _callback_map_ErrorCallback.remove(self.index)


_callback_map_AdapterRequestDeviceCallback = CBMap()


@ffi.def_extern()
def _raw_callback_AdapterRequestDeviceCallback(status, device, message, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_AdapterRequestDeviceCallback.get(idx)
    if cb is not None:
        cb(
            RequestDeviceStatus(status),
            Device(device, add_ref=False),
            _ffi_string(message),
        )


class AdapterRequestDeviceCallback:
    def __init__(self, callback: Callable[["RequestDeviceStatus", "Device", str], None]):
        self.index = _callback_map_AdapterRequestDeviceCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_AdapterRequestDeviceCallback

    def remove(self) -> None:
        _callback_map_AdapterRequestDeviceCallback.remove(self.index)


_callback_map_BufferMapAsyncCallback = CBMap()


@ffi.def_extern()
def _raw_callback_BufferMapAsyncCallback(status, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_BufferMapAsyncCallback.get(idx)
    if cb is not None:
        cb(BufferMapAsyncStatus(status))


class BufferMapAsyncCallback:
    def __init__(self, callback: Callable[["BufferMapAsyncStatus"], None]):
        self.index = _callback_map_BufferMapAsyncCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_BufferMapAsyncCallback

    def remove(self) -> None:
        _callback_map_BufferMapAsyncCallback.remove(self.index)


_callback_map_DeviceCreateComputePipelineAsyncCallback = CBMap()


@ffi.def_extern()
def _raw_callback_DeviceCreateComputePipelineAsyncCallback(
    status, pipeline, message, userdata
):
    idx = _cast_userdata(userdata)
    cb = _callback_map_DeviceCreateComputePipelineAsyncCallback.get(idx)
    if cb is not None:
        cb(
            CreatePipelineAsyncStatus(status),
            ComputePipeline(pipeline, add_ref=False),
            _ffi_string(message),
        )


class DeviceCreateComputePipelineAsyncCallback:
    def __init__(
        self,
        callback: Callable[["CreatePipelineAsyncStatus", "ComputePipeline", str], None],
    ):
        self.index = _callback_map_DeviceCreateComputePipelineAsyncCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_DeviceCreateComputePipelineAsyncCallback

    def remove(self) -> None:
        _callback_map_DeviceCreateComputePipelineAsyncCallback.remove(self.index)


_callback_map_DeviceCreateRenderPipelineAsyncCallback = CBMap()


@ffi.def_extern()
def _raw_callback_DeviceCreateRenderPipelineAsyncCallback(
    status, pipeline, message, userdata
):
    idx = _cast_userdata(userdata)
    cb = _callback_map_DeviceCreateRenderPipelineAsyncCallback.get(idx)
    if cb is not None:
        cb(
            CreatePipelineAsyncStatus(status),
            RenderPipeline(pipeline, add_ref=False),
            _ffi_string(message),
        )


class DeviceCreateRenderPipelineAsyncCallback:
    def __init__(
        self,
        callback: Callable[["CreatePipelineAsyncStatus", "RenderPipeline", str], None],
    ):
        self.index = _callback_map_DeviceCreateRenderPipelineAsyncCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_DeviceCreateRenderPipelineAsyncCallback

    def remove(self) -> None:
        _callback_map_DeviceCreateRenderPipelineAsyncCallback.remove(self.index)


_callback_map_InstanceRequestAdapterCallback = CBMap()


@ffi.def_extern()
def _raw_callback_InstanceRequestAdapterCallback(status, adapter, message, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_InstanceRequestAdapterCallback.get(idx)
    if cb is not None:
        cb(
            RequestAdapterStatus(status),
            Adapter(adapter, add_ref=False),
            _ffi_string(message),
        )


class InstanceRequestAdapterCallback:
    def __init__(
        self, callback: Callable[["RequestAdapterStatus", "Adapter", str], None]
    ):
        self.index = _callback_map_InstanceRequestAdapterCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_InstanceRequestAdapterCallback

    def remove(self) -> None:
        _callback_map_InstanceRequestAdapterCallback.remove(self.index)


_callback_map_QueueOnSubmittedWorkDoneCallback = CBMap()


@ffi.def_extern()
def _raw_callback_QueueOnSubmittedWorkDoneCallback(status, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_QueueOnSubmittedWorkDoneCallback.get(idx)
    if cb is not None:
        cb(QueueWorkDoneStatus(status))


class QueueOnSubmittedWorkDoneCallback:
    def __init__(self, callback: Callable[["QueueWorkDoneStatus"], None]):
        self.index = _callback_map_QueueOnSubmittedWorkDoneCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_QueueOnSubmittedWorkDoneCallback

    def remove(self) -> None:
        _callback_map_QueueOnSubmittedWorkDoneCallback.remove(self.index)


_callback_map_ShaderModuleGetCompilationInfoCallback = CBMap()


@ffi.def_extern()
def _raw_callback_ShaderModuleGetCompilationInfoCallback(
    status, compilationInfo, userdata
):
    idx = _cast_userdata(userdata)
    cb = _callback_map_ShaderModuleGetCompilationInfoCallback.get(idx)
    if cb is not None:
        cb(
            CompilationInfoRequestStatus(status),
            CompilationInfo(cdata=compilationInfo, parent=None),
        )


class ShaderModuleGetCompilationInfoCallback:
    def __init__(
        self,
        callback: Callable[["CompilationInfoRequestStatus", "CompilationInfo"], None],
    ):
        self.index = _callback_map_ShaderModuleGetCompilationInfoCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_ShaderModuleGetCompilationInfoCallback

    def remove(self) -> None:
        _callback_map_ShaderModuleGetCompilationInfoCallback.remove(self.index)


_callback_map_LogCallback = CBMap()


@ffi.def_extern()
def _raw_callback_LogCallback(level, message, userdata):  # noqa
    idx = _cast_userdata(userdata)
    cb = _callback_map_LogCallback.get(idx)
    if cb is not None:
        cb(LogLevel(level), _ffi_string(message))


class LogCallback:
    def __init__(self, callback: Callable[["LogLevel", str], None]):
        self.index = _callback_map_LogCallback.add(callback)
        # Yes, we're just storing ints into pointers.
        self._userdata = ffi.cast("void *", self.index)
        self._ptr = lib._raw_callback_LogCallback

    def remove(self) -> None:
        _callback_map_LogCallback.remove(self.index)


class BindGroupLayoutList:
    def __init__(self, items: List["BindGroupLayout"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUBindGroupLayout[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata


class TextureFormatList:
    def __init__(self, items: List["TextureFormat"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUTextureFormat[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = int(item)


class PresentModeList:
    def __init__(self, items: List["PresentMode"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUPresentMode[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = int(item)


class CompositeAlphaModeList:
    def __init__(self, items: List["CompositeAlphaMode"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUCompositeAlphaMode[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = int(item)


class BindGroupEntryList:
    def __init__(self, items: List["BindGroupEntry"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUBindGroupEntry[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class CompilationMessageList:
    def __init__(self, items: List["CompilationMessage"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUCompilationMessage[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class ConstantEntryList:
    def __init__(self, items: List["ConstantEntry"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUConstantEntry[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class ShaderModuleCompilationHintList:
    def __init__(self, items: List["ShaderModuleCompilationHint"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUShaderModuleCompilationHint[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class VertexAttributeList:
    def __init__(self, items: List["VertexAttribute"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUVertexAttribute[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class BindGroupLayoutEntryList:
    def __init__(self, items: List["BindGroupLayoutEntry"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUBindGroupLayoutEntry[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class FeatureNameList:
    def __init__(self, items: List["FeatureName"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUFeatureName[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = int(item)


class RenderPassColorAttachmentList:
    def __init__(self, items: List["RenderPassColorAttachment"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPURenderPassColorAttachment[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class VertexBufferLayoutList:
    def __init__(self, items: List["VertexBufferLayout"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUVertexBufferLayout[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class ColorTargetStateList:
    def __init__(self, items: List["ColorTargetState"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUColorTargetState[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class PushConstantRangeList:
    def __init__(self, items: List["PushConstantRange"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUPushConstantRange[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = _ffi_deref(item._cdata)


class BufferList:
    def __init__(self, items: List["Buffer"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUBuffer[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata


class SamplerList:
    def __init__(self, items: List["Sampler"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUSampler[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata


class TextureViewList:
    def __init__(self, items: List["TextureView"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUTextureView[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata


class PipelineStatisticNameList:
    def __init__(self, items: List["PipelineStatisticName"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUPipelineStatisticName[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = int(item)


class IntList:
    def __init__(self, items: List[int], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("uint32_t[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item


class CommandBufferList:
    def __init__(self, items: List["CommandBuffer"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPUCommandBuffer[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata


class RenderBundleList:
    def __init__(self, items: List["RenderBundle"], count: int = 0):
        self._stashed = items
        self._count = max(len(items), count)
        self._ptr = _ffi_new("WGPURenderBundle[]", self._count)
        for idx, item in enumerate(items):
            self._ptr[idx] = item._cdata
